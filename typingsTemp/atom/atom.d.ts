// Type definitions for Atom (v0.193.0)
// Project: https://atom.io/
// Definitions by: vvakame <https://github.com/vvakame/>
// Definitions: https://github.com/borisyankov/DefinitelyTyped

// Generated by: https://github.com/david-driscoll/atom-typescript-generator
// Generation tool by david-driscoll <https://github.com/david-driscoll/>
/// <reference path="../event-kit/event-kit.d.ts" />
/// <reference path="../scoped-property-store/scoped-property-store.d.ts" />
/// <reference path="../text-buffer/text-buffer.d.ts" />
/// <reference path="../serializable/serializable.d.ts" />
/// <reference path="../first-mate/first-mate.d.ts" />
/// <reference path="../property-accessors/property-accessors.d.ts" />
/// <reference path="../atom-keymap/atom-keymap.d.ts" />
/// <reference path="../space-pen/space-pen.d.ts" />
/// <reference path="../scandal/scandal.d.ts" />
/// <reference path="../pathwatcher/pathwatcher.d.ts" />
/// <reference path="../../typings/semver/semver.d.ts" />
/// <reference path="../../typings/q/Q.d.ts" />
declare module Atom {
    /**
     * Atom global for dealing with packages, themes, menus, and the window.
     */
    class Atom extends Model {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static version: any /* default */;
    
        /**
         * Load or create the Atom environment in the given mode.
         * This field or method was marked private by atomdoc. Use with caution.
         * @param mode? - A {String} mode that is either 'editor' or 'spec' depending on the kind of environment you want to build.
        Returns an Atom instance, fully initialized
         */
        static loadOrCreate(mode? : string) : any;
    
        /**
         * Deserializes the Atom environment from a state object 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        static deserialize(state? : any) : any;
    
        /**
         * Loads and returns the serialized state corresponding to this window
         * if it exists; otherwise returns undefined. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        static loadState(mode? : any) : any;
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
        Returns the path where the state for the current window will be
located if it exists.
         */
        static getStateKey(paths? : any, mode? : any) : any;
    
        /**
         * Get the directory path to Atom's configuration area.
         * This field or method was marked private by atomdoc. Use with caution.
        Returns the absolute path to ~/.atom
         */
        static getConfigDirPath() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static getStorageFolder() : StorageFolder;
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
        Returns the load settings hash associated with the current window.
         */
        static getLoadSettings() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static updateLoadSetting(key? : any, value? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static getCurrentWindow() : AtomWindow;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        state: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        workspaceViewParentSelector: ScopedPropertyStore.Selector;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        lastUncaughtError: any /* default */;
    
        /**
         * A {CommandRegistry} instance 
         */
        commands: CommandRegistry;
    
        /**
         * A {Config} instance 
         */
        config: Config;
    
        /**
         * A {Clipboard} instance 
         */
        clipboard: Clipboard;
    
        /**
         * A {ContextMenuManager} instance 
         */
        contextMenu: ContextMenuManager;
    
        /**
         * A {MenuManager} instance 
         */
        menu: MenuManager;
    
        /**
         * A {KeymapManager} instance 
         */
        keymaps: AtomKeymap.KeymapManager;
    
        /**
         * A {TooltipManager} instance 
         */
        tooltips: TooltipManager;
    
        /**
         * A {NotificationManager} instance 
         */
        notifications: NotificationManager;
    
        /**
         * A {Project} instance 
         */
        project: Project;
    
        /**
         * A {GrammarRegistry} instance 
         */
        grammars: GrammarRegistry;
    
        /**
         * A {PackageManager} instance 
         */
        packages: PackageManager;
    
        /**
         * A {ThemeManager} instance 
         */
        themes: ThemeManager;
    
        /**
         * A {StyleManager} instance 
         */
        styles: StyleManager;
    
        /**
         * A {DeserializerManager} instance 
         */
        deserializers: DeserializerManager;
    
        /**
         * A {ViewRegistry} instance 
         */
        views: ViewRegistry;
    
        /**
         * A {Workspace} instance 
         */
        workspace: Workspace;
    
        /**
         * Call .loadOrCreate instead 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        constructor(state? : any);
    
        /**
         * Sets up the basic services that should be available in all modes
         * (both spec and application).
         * 
         * Call after this instance has been assigned to the `atom` global. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        initialize() : any;
    
        /**
         * Invoke the given callback whenever {::beep} is called.
         * @param callback? - {Function} to be called whenever {::beep} is called.
         */
        onDidBeep(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when there is an unhandled error, but
         * before the devtools pop open
         * @param callback? - {Function} to be called whenever there is an unhandled error
         */
        onWillThrowError(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback whenever there is an unhandled error.
         * @param callback? - {Function} to be called whenever there is an unhandled error
         */
        onDidThrowError(callback? : Function) : EventKit.Disposable;
    
        /**
         * Is the current window in development mode? 
         */
        inDevMode() : any;
    
        /**
         * Is the current window in safe mode? 
         */
        inSafeMode() : any;
    
        /**
         * Is the current window running specs? 
         */
        inSpecMode() : any;
    
        /**
         * Get the version of the Atom application.
        Returns the version text {String}.
         */
        getVersion() : string;
    
        /**
         * Determine whether the current version is an official release. 
         */
        isReleasedVersion() : boolean;
    
        /**
         * Get the directory path to Atom's configuration area.
         * This field or method was marked private by atomdoc. Use with caution.
        Returns the absolute path to ~/.atom
         */
        getConfigDirPath() : any;
    
        /**
         * Get the time taken to completely load the current window.
         * 
         * This time include things like loading and activating packages, creating
         * DOM elements for the editor, and reading the config.
        Returns the {Number} of milliseconds taken to load the window or null
if the window hasn't finished loading yet.
         */
        getWindowLoadTime() : number;
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
        Returns the load settings hash associated with the current window.
         */
        getLoadSettings() : any;
    
        /**
         * Open a new Atom window using the given options.
         * 
         * Calling this method without an options parameter will open a prompt to pick
         * a file/folder to open in the new window.
         * @param options? - An {Object} with the following keys:
         */
        open(options? : Object) : any;
    
        /**
         * Prompt the user to select one or more folders.
         * @param callback? - A {Function} to call once the user has confirmed the selection.
         */
        pickFolder(callback? : Function) : any;
    
        /**
         * Close the current window. 
         */
        close() : any;
    
        /**
         * Get the size of current window.
        Returns an {Object} in the format `{width: 1000, height: 700}`
         */
        getSize() : Object;
    
        /**
         * Set the size of current window.
         * @param width? - The {Number} of pixels.
         * @param height? - The {Number} of pixels. 
         */
        setSize(width? : number, height? : number) : void;
    
        /**
         * Get the position of current window.
         */
        getPosition() : TextBuffer.Point;
    
        /**
         * Set the position of current window.
         * @param x? - The {Number} of pixels.
         * @param y? - The {Number} of pixels. 
         */
        setPosition(x? : number, y? : number) : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getCurrentWindow() : AtomWindow;
    
        /**
         * Move current window to the center of the screen. 
         */
        center() : any;
    
        /**
         * Focus the current window. 
         */
        focus() : any;
    
        /**
         * Show the current window. 
         */
        show() : any;
    
        /**
         * Hide the current window. 
         */
        hide() : any;
    
        /**
         * Reload the current window. 
         */
        reload() : any;
    
        isMaximixed() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        maximize() : any;
    
        /**
         * Is the current window in full screen mode? 
         */
        isFullScreen() : boolean;
    
        /**
         * Set the full screen state of the current window. 
         */
        setFullScreen(fullScreen? : any) : void;
    
        /**
         * Toggle the full screen state of the current window. 
         */
        toggleFullScreen() : any;
    
        /**
         * Schedule the window to be shown and focused on the next tick.
         * 
         * This is done in a next tick to prevent a white flicker from occurring
         * if called synchronously. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        displayWindow(maximize? : any) : any;
    
        /**
         * Get the dimensions of this window.
         * This field or method was marked private by atomdoc. Use with caution.
        Returns an {Object} with the following keys:

* `x`      The window's x-position {Number}.
* `y`      The window's y-position {Number}.
* `width`  The window's width {Number}.
* `height` The window's height {Number}.
         */
        getWindowDimensions() : Object;
    
        /**
         * Set the dimensions of the window.
         * 
         * The window will be centered if either the x or y coordinate is not set
         * in the dimensions parameter. If x or y are omitted the window will be
         * centered. If height or width are omitted only the position will be changed.
         * This field or method was marked private by atomdoc. Use with caution.
         */
        setWindowDimensions(x? : any, y? : any, width? : any, height? : any) : void;
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        isValidDimensions(x? : any, y? : any, width? : any, height? : any) : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        storeDefaultWindowDimensions() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getDefaultWindowDimensions() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        restoreWindowDimensions() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        storeWindowDimensions() : any;
    
        /**
         * Call this method when establishing a real application window. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        startEditorWindow() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        unloadEditorWindow() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        removeEditorWindow() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        openInitialEmptyEditorIfNecessary() : any;
    
        /**
         * Visually and audibly trigger a beep. 
         */
        beep() : any;
    
        /**
         * A flexible way to open a dialog akin to an alert dialog.
        Returns the chosen button index {Number} if the buttons option was an array.
         */
        confirm(message? : any, detailedMessage? : any, buttons? : any) : number;
    
        /**
         * Open the dev tools for the current window. 
         */
        openDevTools() : any;
    
        /**
         * Toggle the visibility of the dev tools for the current window. 
         */
        toggleDevTools() : any;
    
        /**
         * Execute code in dev tools. 
         */
        executeJavaScriptInDevTools(code? : any) : any;
    
        /**
         * Private
         * This field or method was marked private by atomdoc. Use with caution.
         */
        deserializeProject() : Project;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        deserializeWorkspaceView() : WorkspaceView;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        deserializePackageStates() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        deserializeEditorWindow() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        loadConfig() : Config;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        loadThemes() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        watchThemes() : any;
    
        /**
         * Notify the browser project of the window's current project path 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        watchProjectPath() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        exit(status? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setDocumentEdited(edited? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setRepresentedFilename(filename? : string) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        addProjectFolder() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        showSaveDialog(callback? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        showSaveDialogSync(defaultPath? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        saveSync() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        crashMainProcess() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        crashRenderProcess() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getUserInitScriptPath() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        requireUserInitScript() : any;
    
        /**
         * Require the module with the given globals.
         * 
         * The globals will be set on the `window` object and removed after the
         * require completes.
         * This field or method was marked private by atomdoc. Use with caution.
         * @param id? - The {String} module name or path.
         * @param globals? - An optional {Object} to set as globals during require. 
         */
        requireWithGlobals(id? : string, globals? : Object) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onUpdateAvailable(callback? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateAvailable(details? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setBodyPlatformClass() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setAutoHideMenuBar(autoHide? : any) : void;
    
    
        emitter: EventKit.Emitter;
    }

    /**
     * Used to manage the global application menu.
     */
    class ApplicationMenu {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        version: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(version? : any);
    
        /**
         * Updates the entire menu with the given keybindings.
         * 
         * window - The BrowserWindow this menu template is associated with.
         * template - The Object which describes the menu to display.
         * keystrokesByCommand - An Object where the keys are commands and the values
         *                       are Arrays containing the keystroke. 
         */
        update(window? : any, template? : any, keystrokesByCommand? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setActiveTemplate(template? : any) : void;
    
        /**
         * Register a BrowserWindow with this application menu. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        addWindow(window? : any) : any;
    
        /**
         * Flattens the given menu and submenu items into an single Array.
         * 
         * menu - A complete menu configuration object for atom-shell's menu API.
         * This field or method was marked private by atomdoc. Use with caution.
        Returns an Array of native menu items.
         */
        flattenMenuItems(menu? : any) : any;
    
        /**
         * Flattens the given menu template into an single Array.
         * 
         * template - An object describing the menu item.
         * This field or method was marked private by atomdoc. Use with caution.
        Returns an Array of native menu items.
         */
        flattenMenuTemplate(template? : any) : any;
    
        /**
         * Used to make all window related menu items are active.
         * 
         * enable - If true enables all window specific items, if false disables all
         *          window specific items. 
         */
        enableWindowSpecificItems(enable? : any) : any;
    
        /**
         * Replaces VERSION with the current version. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        substituteVersion(template? : any) : any;
    
        /**
         * Sets the proper visible state the update menu items 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        showUpdateMenuItem(state? : any) : any;
    
        /**
         * Default list of menu items.
         * This field or method was marked private by atomdoc. Use with caution.
        Returns an Array of menu item Objects.
         */
        getDefaultTemplate() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        focusedWindow() : any;
    
        /**
         * Combines a menu template with the appropriate keystroke.
         * 
         * template - An Object conforming to atom-shell's menu api but lacking
         *            accelerator and click properties.
         * keystrokesByCommand - An Object where the keys are commands and the values
         *                       are Arrays containing the keystroke.
         * This field or method was marked private by atomdoc. Use with caution.
        Returns a complete menu configuration object for atom-shell's menu API.
         */
        translateTemplate(template? : any, keystrokesByCommand? : any) : any;
    
        /**
         * Determine the accelerator for a given command.
         * 
         * command - The name of the command.
         * keystrokesByCommand - An Object where the keys are commands and the values
         *                       are Arrays containing the keystroke.
         * This field or method was marked private by atomdoc. Use with caution.
        Returns a String containing the keystroke in a format that can be interpreted
  by atom shell to provide nice icons where available.
         */
        acceleratorForCommand(command? : any, keystrokesByCommand? : any) : any;
    
    }

    /**
     * The application's singleton class.
     */
    class AtomApplication {
        /**
         * The entry point into the Atom application. 
         */
        static open(options? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        windows: AtomWindow[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        applicationMenu: ApplicationMenu;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        atomProtocolHandler: AtomProtocolHandler;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        resourcePath: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        version: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        exit(status? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(options? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        openWithOptions(pathsToOpen? : any, urlsToOpen? : any, test? : any, pidToKillWhenClosed? : any, devMode? : any, safeMode? : any, apiPreviewMode? : any, newWindow? : any, specDirectory? : Pathwatcher.Directory, logFile? : Pathwatcher.File) : any;
    
        /**
         * Removes the {AtomWindow} from the global window list. 
         */
        removeWindow(window? : any) : any;
    
        /**
         * Adds the {AtomWindow} to the global window list. 
         */
        addWindow(window? : any) : any;
    
        /**
         * Creates server to listen for additional atom application launches.
         * 
         * You can run the atom command multiple times, but after the first launch
         * the other launches will just pass their information to this server and then
         * close immediately. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        listenForArgumentsFromNewProcess() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        deleteSocketFile() : void;
    
        /**
         * Configures required javascript environment flags. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        setupJavaScriptArguments() : void;
    
        /**
         * Registers basic application commands, non-idempotent. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        handleEvents() : any;
    
        /**
         * Executes the given command.
         * 
         * If it isn't handled globally, delegate to the currently focused window.
         * 
         * command - The string representing the command.
         * args - The optional arguments to pass along. 
         */
        sendCommand(command? : any, args? : any) : any;
    
        /**
         * Executes the given command on the given window.
         * 
         * command - The string representing the command.
         * atomWindow - The {AtomWindow} to send the command to.
         * args - The optional arguments to pass along. 
         */
        sendCommandToWindow(command? : any, atomWindow? : AtomWindow, args? : any) : any;
    
        /**
         * Translates the command into OS X action and sends it to application's first
         * responder. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        sendCommandToFirstResponder(command? : any) : any;
    
        /**
         * Open the given path in the focused window when the event is
         * triggered.
         * 
         * A new window will be created if there is no currently focused window.
         * 
         * eventName - The event to listen for.
         * pathToOpen - The path to open when the event is triggered. 
         */
        openPathOnEvent(eventName? : string, pathToOpen? : any) : any;
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
        Returns the {AtomWindow} for the given paths.
         */
        windowForPaths(pathsToOpen? : any, devMode? : any) : AtomWindow;
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
        Returns the {AtomWindow} for the given ipc event.
         */
        windowForEvent(sender? : any) : AtomWindow;
    
        focusedWindow() : AtomWindow;
    
        /**
         * Opens a single path, in an existing window if possible.
         * 
         * options -
         *   :pathToOpen - The file path to open
         *   :pidToKillWhenClosed - The integer of the pid to kill
         *   :newWindow - Boolean of whether this should be opened in a new window.
         *   :devMode - Boolean to control the opened window's dev mode.
         *   :safeMode - Boolean to control the opened window's safe mode.
         *   :apiPreviewMode - Boolean to control the opened window's 1.0 API preview mode.
         *   :window - {AtomWindow} to open file paths in. 
         */
        openPath(pathToOpen? : any, pidToKillWhenClosed? : any, newWindow? : any, devMode? : any, safeMode? : any, apiPreviewMode? : any, window? : any) : any;
    
        /**
         * Opens multiple paths, in existing windows if possible.
         * 
         * options -
         *   :pathsToOpen - The array of file paths to open
         *   :pidToKillWhenClosed - The integer of the pid to kill
         *   :newWindow - Boolean of whether this should be opened in a new window.
         *   :devMode - Boolean to control the opened window's dev mode.
         *   :safeMode - Boolean to control the opened window's safe mode.
         *   :apiPreviewMode - Boolean to control the opened window's 1.0 API preview mode.
         *   :windowDimensions - Object with height and width keys.
         *   :window - {AtomWindow} to open file paths in. 
         */
        openPaths(pathsToOpen? : any, pidToKillWhenClosed? : any, newWindow? : any, devMode? : any, safeMode? : any, apiPreviewMode? : any, windowDimensions? : any, window? : any) : any;
    
        /**
         * Kill all processes associated with opened windows. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        killAllProcesses() : any;
    
        /**
         * Kill process associated with the given opened window. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        killProcessForWindow(openedWindow? : any) : any;
    
        /**
         * Kill the process with the given pid. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        killProcess(pid? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        saveState() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        loadState() : any;
    
        /**
         * Open an atom:// url.
         * 
         * The host of the URL being opened is assumed to be the package name
         * responsible for opening the URL.  A new window will be created with
         * that package's `urlMain` as the bootstrap script.
         * 
         * options -
         *   :urlToOpen - The atom:// url to open.
         *   :devMode - Boolean to control the opened window's dev mode.
         *   :safeMode - Boolean to control the opened window's safe mode. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        openUrl(urlToOpen? : any, devMode? : any, safeMode? : any) : any;
    
        /**
         * Opens up a new {AtomWindow} to run specs within.
         * 
         * options -
         *   :exitWhenDone - A Boolean that, if true, will close the window upon
         *                   completion.
         *   :resourcePath - The path to include specs from.
         *   :specPath - The directory to load specs from.
         *   :safeMode - A Boolean that, if true, won't run specs from ~/.atom/packages
         *               and ~/.atom/dev/packages, defaults to false. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        runSpecs(exitWhenDone? : any, resourcePath? : any, specDirectory? : Pathwatcher.Directory, logFile? : Pathwatcher.File, safeMode? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        runBenchmarks(exitWhenDone? : any, specDirectory? : Pathwatcher.Directory) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        locationForPathToOpen(pathToOpen? : any) : any;
    
        /**
         * Opens a native dialog to prompt the user for a path.
         * 
         * Once paths are selected, they're opened in a new or existing {AtomWindow}s.
         * 
         * options -
         *   :type - A String which specifies the type of the dialog, could be 'file',
         *           'folder' or 'all'. The 'all' is only available on OS X.
         *   :devMode - A Boolean which controls whether any newly opened windows
         *              should be in dev mode or not.
         *   :safeMode - A Boolean which controls whether any newly opened windows
         *               should be in safe mode or not.
         *   :window - An {AtomWindow} to use for opening a selected file path. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        promptForPathToOpen(type? : any, options? : (devMode? : any,safeMode? : any,apiPreviewMode? : any,window? : any) => any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        promptForPath(type? : any, callback? : any) : any;
    
    }

    /**
     * Handles requests with 'atom' protocol.
     */
    class AtomProtocolHandler {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(resourcePath? : any, safeMode? : any);
    
        /**
         * Creates the 'atom' custom protocol handler. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        registerAtomProtocol() : any;
    
    }

    /**
     * AtomWindow
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class AtomWindow {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static includeShellLoadTime: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static iconPath() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        browserWindow: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        loaded: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isSpec: boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(settings? : void);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setLoadSettings(loadSettingsObj? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getLoadSettings() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        hasProjectPath() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setupContextMenu() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        containsPaths(paths? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        containsPath(pathToCheck? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        handleEvents() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        openPath(pathToOpen? : any, initialLine? : any, initialColumn? : number) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        openLocations(locationsToOpen? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        sendMessage(message? : any, detail? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        sendCommand(command? : any, args? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        sendCommandToBrowserWindow(command? : any, args? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getDimensions() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        close() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        focus() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        minimize() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        maximize() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        restore() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        handlesAtomCommands() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isFocused() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isMinimized() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isWebViewFocused() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isSpecWindow() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        reload() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        toggleDevTools() : any;
    
    }

    /**
     * AutoUpdateManager
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class AutoUpdateManager {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        version: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(version? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setupAutoUpdater() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        emitUpdateAvailableEvent(windows? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setState(state? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getState() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        check(hidePopups? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        install() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onUpdateNotAvailable() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onUpdateError(event? : any, message? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getWindows() : any;
    
    }

    /**
     * AutoUpdater
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class AutoUpdater {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setFeedUrl(updateUrl? : void) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        quitAndInstall() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        downloadUpdate(callback? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        installUpdate(callback? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        supportsUpdates() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        checkForUpdates() : any;
    
    }

    /**
     * ContextMenu
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class ContextMenu {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        atomWindow: AtomWindow;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(template? : any, atomWindow? : AtomWindow);
    
        /**
         * It's necessary to build the event handlers in this process, otherwise
         * closures are dragged across processes and failed to be garbage collected
         * appropriately. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        createClickHandlers(template? : any) : any;
    
    }

    /**
     * Like {BufferedProcess}, but accepts a Node script as the command
     * to run.
     */
    export class BufferedNodeProcess extends BufferedProcess {
        /**
         * Runs the given Node script by spawning a new child process.
         * @param options? - An {Object} with the following keys:
         */
        constructor(command? : any, args? : any, options? : Object, stdout? : any, stderr? : any, exit? : any);
    
    }

    /**
     * A wrapper which provides standard error/output line buffering for
     * Node's ChildProcess.
     */
    export class BufferedProcess {
        /**
         * Runs the given command by spawning a new child process.
         * @param options? - An {Object} with the following keys:
         */
        constructor(command? : any, args? : any, options? : Object, stdout? : any, stderr? : any, exit? : any);
    
        /**
         * Will call your callback when an error will be raised by the process.
         * Usually this is due to the command not being available or not on the PATH.
         * You can call `handle()` on the object passed to your callback to indicate
         * that you have handled this error.
         * @param callback? - {Function} callback
         */
        onWillThrowError(callback? : Function) : EventKit.Disposable;
    
        /**
         * Helper method to pass data line by line.
         * This field or method was marked private by atomdoc. Use with caution.
         * @param stream? - The Stream to read from.
         * @param onLines? - The callback to call with each line of data.
         * @param onDone? - The callback to call when the stream has closed. 
         */
        bufferStream(stream? : any, onLines? : any, onDone? : any) : any;
    
        /**
         * Kill all child processes of the spawned cmd.exe process on Windows.
         * 
         * This is required since killing the cmd.exe does not terminate child
         * processes. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        killOnWindows() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        killProcess() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isExplorerCommand(command? : any) : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getCmdPath() : any;
    
        /**
         * Terminate the process. 
         */
        kill() : any;
    
    }

    /**
     * Represents the clipboard used for copying and pasting in Atom.
     */
    class Clipboard {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        metadata: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        signatureForMetadata: any /* default */;
    
        /**
         * Creates an `md5` hash of some text.
         * This field or method was marked private by atomdoc. Use with caution.
         * @param text? - A {String} to hash.
        Returns a hashed {String}.
         */
        md5(text? : string) : string;
    
        /**
         * Write the given text to the clipboard.
         * 
         * The metadata associated with the text is available by calling
         * {::readWithMetadata}.
         * @param text? - The {String} to store.
         * @param metadata? - The additional info to associate with the text. 
         */
        write(text? : string, metadata? : any) : any;
    
        /**
         * Read the text from the clipboard.
        Returns a {String}.
         */
        read() : string;
    
        /**
         * Read the text from the clipboard and return both the text and the
         * associated metadata.
        Returns an {Object} with the following keys:

* `text` The {String} clipboard text.
* `metadata` The metadata stored by an earlier call to {::write}.
         */
        readWithMetadata() : Object;
    
    }

    /**
     * A simple color class returned from {Config::get} when the value
     * at the key path is of type 'color'. 
     */
    class Color {
        /**
         * Parse a {String} or {Object} into a {Color}.
         * @param value? - A {String} such as `'white'`, `#ff00ff`, or `'rgba(255, 15, 60, .75)'` or an {Object} with `red`, `green`, `blue`, and `alpha` properties.
        Returns a {Color} or `null` if it cannot be parsed.
         */
        static parse(value? : string) : Color;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(red? : any, green? : any, blue? : any, alpha? : any);
    
        toHexString() : string;
    
        toRGBAString() : string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isEqual(color? : Color) : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        clone() : any;
    
    }

    /**
     * Associates listener functions with commands in a
     * context-sensitive way using CSS selectors. You can access a global instance of
     * this class via `atom.commands`, and commands registered there will be
     * presented in the command palette.
     */
    class CommandRegistry {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        rootNode: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(rootNode? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        destroy() : void;
    
        /**
         * Add one or more command listeners associated with a selector.
        Returns a {Disposable} on which `.dispose()` can be called to remove the
added command handler(s).
         */
        add(target? : any, commandName? : string, callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        addSelectorBasedListener(selector? : SelectorBasedListener, commandName? : string, callback? : any) : SelectorBasedListener;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        addInlineListener(element? : any, commandName? : string, callback? : any) : InlineListener;
    
        /**
         * Find all registered commands matching a query.
        Returns an {Array} of {Object}s containing the following keys:

* `name` The name of the command. For example, `user:insert-date`.
* `displayName` The display name of the command. For example,
  `User: Insert Date`.
* `jQuery` Present if the command was registered with the legacy
  `$::command` method.
         */
        findCommands(target? : any) : Object[];
    
        /**
         * Simulate the dispatch of a command on a DOM node.
         * 
         * This can be useful for testing when you want to simulate the invocation of a
         * command on a detached DOM node. Otherwise, the DOM node in question needs to
         * be attached to the document so the event bubbles up to the root node to be
         * processed.
         * @param target? - The DOM node at which to start bubbling the command event.
         * @param commandName? - {String} indicating the name of the command to dispatch. 
         */
        dispatch(target? : any, commandName? : string, detail? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onWillDispatch(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getSnapshot() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        restoreSnapshot(snapshot? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        handleCommandEvent(originalEvent? : any) : AtomKeymap.CommandEvent;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        commandRegistered(commandName? : string) : any;
    
    }

    /**
     * SelectorBasedListener
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class SelectorBasedListener {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        selector: ScopedPropertyStore.Selector;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        callback: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(selector? : ScopedPropertyStore.Selector, callback? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        compare(other? : any) : any;
    
    }

    /**
     * InlineListener
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class InlineListener {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        callback: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(callback? : any);
    
    }

    /**
     * Used to access all of Atom's configuration details.
     */
    class Config {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static undefined: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static addSchemaEnforcer(typeName? : string, enforcerFunction? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static addSchemaEnforcers(filters? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static executeSchemaEnforcers(keyPath? : any, value? : any, schema? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        configDirPath: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        resourcePath: any /* default */;
    
        /**
         * Created during initialization, available as `atom.config` 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        constructor(configDirPath? : any, resourcePath? : any);
    
        /**
         * Add a listener for changes to a given key path. This is different
         * than {::onDidChange} in that it will immediately call your callback with the
         * current value of the config entry.
         * 
         * ### Examples
         * 
         * You might want to be notified when the themes change. We'll watch
         * `core.themes` for changes
         * 
         * ```coffee
         * atom.config.observe 'core.themes', (value) ->
         *   # do stuff with value
         * ```
         */
        observe() : EventKit.Disposable;
    
        /**
         * Add a listener for changes to a given key path. If `keyPath` is
         * not specified, your callback will be called on changes to any key.
         */
        onDidChange() : EventKit.Disposable;
    
        /**
         * Retrieves the setting for the given key.
         * 
         * ### Examples
         * 
         * You might want to know what themes are enabled, so check `core.themes`
         * 
         * ```coffee
         * atom.config.get('core.themes')
         * ```
         * 
         * With scope descriptors you can get settings within a specific editor
         * scope. For example, you might want to know `editor.tabLength` for ruby
         * files.
         * 
         * ```coffee
         * atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2
         * ```
         * 
         * This setting in ruby files might be different than the global tabLength setting
         * 
         * ```coffee
         * atom.config.get('editor.tabLength') # => 4
         * atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2
         * ```
         * 
         * You can get the language scope descriptor via
         * {TextEditor::getRootScopeDescriptor}. This will get the setting specifically
         * for the editor's language.
         * 
         * ```coffee
         * atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2
         * ```
         * 
         * Additionally, you can get the setting at the specific cursor position.
         * 
         * ```coffee
         * scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()
         * atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2
         * ```
        Returns the value from Atom's default settings, the user's configuration
file in the type specified by the configuration schema.
         */
        get() : any;
    
        /**
         * Get all of the values for the given key-path, along with their
         * associated scope selector.
         * @param keyPath? - The {String} name of the key to retrieve
         * @param options? - {Object} see the `options` argument to {::get}
        Returns an {Array} of {Object}s with the following keys:

* `scopeDescriptor` The {ScopeDescriptor} with which the value is associated
* `value` The value for the key-path
         */
        getAll(keyPath? : string, options? : Object) : Object[];
    
        /**
         * Sets the value for a configuration setting.
         * 
         * This value is stored in Atom's internal configuration file.
         * 
         * ### Examples
         * 
         * You might want to change the themes programmatically:
         * 
         * ```coffee
         * atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])
         * ```
         * 
         * You can also set scoped settings. For example, you might want change the
         * `editor.tabLength` only for ruby files.
         * 
         * ```coffee
         * atom.config.get('editor.tabLength') # => 4
         * atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4
         * atom.config.get('editor.tabLength', scope: ['source.js']) # => 4
         * 
         * # Set ruby to 2
         * atom.config.set('editor.tabLength', 2, scopeSelector: 'source.ruby') # => true
         * 
         * # Notice it's only set to 2 in the case of ruby
         * atom.config.get('editor.tabLength') # => 4
         * atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2
         * atom.config.get('editor.tabLength', scope: ['source.js']) # => 4
         * ```
         */
        set() : void;
    
        /**
         * Restore the setting at `keyPath` to its default value.
         * @param keyPath? - The {String} name of the key.
         * @param options? - {Object}
         */
        unset(keyPath? : string, options? : Object) : any;
    
        /**
         * Get an {Array} of all of the `source` {String}s with which
         * settings have been added via {::set}. 
         */
        getSources() : any;
    
        /**
         * Retrieve the schema for a specific key path. The schema will tell
         * you what type the keyPath expects, and other metadata about the config
         * option.
         * @param keyPath? - The {String} name of the key.
        Returns an {Object} eg. `{type: 'integer', default: 23, minimum: 1}`.
        Returns `null` when the keyPath has no schema specified.
         */
        getSchema(keyPath? : string) : Object | any;
    
        /**
         * Get the {String} path to the config file being used. 
         */
        getUserConfigPath() : any;
    
        /**
         * Suppress calls to handler functions registered with {::onDidChange}
         * and {::observe} for the duration of `callback`. After `callback` executes,
         * handlers will be called once if the value for their key-path has changed.
         * @param callback? - {Function} to execute while suppressing calls to handlers. 
         */
        transact(callback? : Function) : any;
    
        /**
         * Internal methods used by core
         * This field or method was marked private by atomdoc. Use with caution.
         */
        pushAtKeyPath(keyPath? : any, value? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        unshiftAtKeyPath(keyPath? : any, value? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        removeAtKeyPath(keyPath? : any, value? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setSchema(keyPath? : any, schema? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        load() : any;
    
        /**
         * Private methods managing the user's config file
         * This field or method was marked private by atomdoc. Use with caution.
         */
        initializeConfigDirectory(done? : any) : Pathwatcher.Directory;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        loadUserConfig() : Config;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        observeUserConfig() : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        unobserveUserConfig() : Config;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        notifyFailure(errorMessage? : any, detail? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        save() : void;
    
        /**
         * Private methods managing global settings
         * This field or method was marked private by atomdoc. Use with caution.
         */
        resetUserSettings(newSettings? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getRawValue(keyPath? : any, options? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setRawValue(keyPath? : any, value? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        observeKeyPath(keyPath? : any, options? : any, callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidChangeKeyPath(keyPath? : any, callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isSubKeyPath(keyPath? : any, subKeyPath? : any) : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setRawDefault(keyPath? : any, value? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setDefaults(keyPath? : any, defaults? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        deepClone(object? : any) : any;
    
        /**
         * `schema` will look something like this
         * 
         * ```coffee
         * type: 'string'
         * default: 'ok'
         * scopes:
         *   '.source.js':
         *     default: 'omg'
         * ```
         * This field or method was marked private by atomdoc. Use with caution.
         */
        setScopedDefaultsFromSchema(keyPath? : any, schema? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        extractDefaultsFromSchema(schema? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        makeValueConformToSchema(keyPath? : any, value? : any, options? : any) : any;
    
        /**
         * When the schema is changed / added, there may be values set in the config
         * that do not conform to the schema. This will reset make them conform. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        resetSettingsForSchemaChange(source? : any) : void;
    
        /**
         * Private Scoped Settings
         * This field or method was marked private by atomdoc. Use with caution.
         */
        priorityForSource(source? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        emitChangeEvent() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        resetUserScopedSettings(newScopedSettings? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setRawScopedValue(keyPath? : any, value? : any, source? : any, selector? : ScopedPropertyStore.Selector, options? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getRawScopedValue(scopeDescriptor? : ScopeDescriptor, keyPath? : any, options? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        observeScopedKeyPath(scope? : Scope, keyPath? : any, callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidChangeScopedKeyPath(scope? : Scope, keyPath? : any, callback? : any) : EventKit.Disposable;
    
    }

    /**
     * Provides a registry for commands that you'd like to appear in the
     * context menu.
     */
    class ContextMenuManager {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        resourcePath: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        devMode: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(resourcePath? : any, devMode? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        loadPlatformItems() : any;
    
        /**
         * Add context menu items scoped by CSS selectors.
         * @param itemsBySelector? - An {Object} whose keys are CSS selectors and whose values are {Array}s of item {Object}s containing the following keys:
         */
        add(itemsBySelector? : Object) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        templateForElement(target? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        templateForEvent(event? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        convertLegacyItemsBySelector(legacyItemsBySelector? : ScopedPropertyStore.Selector, devMode? : any) : ScopedPropertyStore.Selector;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        convertLegacyItems(legacyItems? : any, devMode? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        showForEvent(event? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        clear() : any;
    
    }

    /**
     * ContextMenuItemSet
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class ContextMenuItemSet {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        selector: ScopedPropertyStore.Selector;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        items: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(selector? : ScopedPropertyStore.Selector, items? : any);
    
    }

    /**
     * The `Cursor` class represents the little blinking line identifying
     * where text can be inserted.
     */
    class Cursor extends Model {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        editor: Atom.TextEditor;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        marker: Marker;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        screenPosition: TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        bufferPosition: TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        goalColumn: number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        visible: boolean;
    
        /**
         * Instantiated by a {TextEditor} 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        constructor(editor? : TextEditor, marker? : Marker, id? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        destroy() : void;
    
        /**
         * Calls your `callback` when the cursor has been moved.
         * @param callback? - {Function}
         */
        onDidChangePosition(callback? : Function) : TextBuffer.Point;
    
        /**
         * Calls your `callback` when the cursor is destroyed
         * @param callback? - {Function}
         */
        onDidDestroy(callback? : Function) : EventKit.Disposable;
    
        /**
         * Calls your `callback` when the cursor's visibility has changed
         * @param callback? - {Function}
         */
        onDidChangeVisibility(callback? : Function) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        on(eventName? : string) : any;
    
        /**
         * Moves a cursor to a given screen position.
         * @param screenPosition? - {Array} of two numbers: the screen row, and the screen column.
         * @param options? - {Object} with the following keys:
         */
        setScreenPosition(screenPosition? : any[], options? : Object) : TextBuffer.Point;
    
        getScreenPosition() : TextBuffer.Point;
    
        /**
         * Moves a cursor to a given buffer position.
         * @param bufferPosition? - {Array} of two numbers: the buffer row, and the buffer column.
         * @param options? - {Object} with the following keys:
         */
        setBufferPosition(bufferPosition? : any[], options? : Object) : TextBuffer.Point;
    
        getBufferPosition() : TextBuffer.Point;
    
        getScreenRow() : number;
    
        getScreenColumn() : number;
    
        /**
         * Retrieves the cursor's current buffer row. 
         */
        getBufferRow() : number;
    
        getBufferColumn() : number;
    
        getCurrentBufferLine() : any;
    
        isAtBeginningOfLine() : boolean;
    
        isAtEndOfLine() : boolean;
    
        getMarker() : Marker;
    
        /**
         * Identifies if the cursor is surrounded by whitespace.
         * 
         * "Surrounded" here means that the character directly before and after the
         * cursor are both whitespace.
         */
        isSurroundedByWhitespace() : boolean;
    
        /**
         * 
         * 
         * This method returns false if the character before or after the cursor is
         * whitespace.
         */
        isBetweenWordAndNonWord() : boolean;
    
        isInsideWord(options? : Object) : boolean;
    
        getIndentLevel() : any;
    
        /**
         * Retrieves the scope descriptor for the cursor's current position.
         */
        getScopeDescriptor() : ScopeDescriptor;
    
        hasPrecedingCharactersOnLine() : any;
    
        /**
         * Identifies if this cursor is the last in the {TextEditor}.
         * 
         * "Last" is defined as the most recently added cursor.
         */
        isLastCursor() : boolean;
    
        /**
         * Moves the cursor up one screen row.
         * @param rowCount? - {Number} number of rows to move (default: 1)
         * @param options? - {Object} with the following keys:
         * @param moveToEndOfSelection? - if true, move to the left of the selection if a selection exists. 
         */
        moveUp(rowCount? : number, options? : { moveToEndOfSelection? : void }) : void;
    
        /**
         * Moves the cursor down one screen row.
         * @param rowCount? - {Number} number of rows to move (default: 1)
         * @param options? - {Object} with the following keys:
         * @param moveToEndOfSelection? - if true, move to the left of the selection if a selection exists. 
         */
        moveDown(rowCount? : number, options? : { moveToEndOfSelection? : void }) : void;
    
        /**
         * Moves the cursor left one screen column.
         * @param columnCount? - {Number} number of columns to move (default: 1)
         * @param options? - {Object} with the following keys:
         * @param moveToEndOfSelection? - if true, move to the left of the selection if a selection exists. 
         */
        moveLeft(columnCount? : number, options? : { moveToEndOfSelection? : void }) : void;
    
        /**
         * Moves the cursor right one screen column.
         * @param columnCount? - {Number} number of columns to move (default: 1)
         * @param options? - {Object} with the following keys:
         * @param moveToEndOfSelection? - if true, move to the right of the selection if a selection exists. 
         */
        moveRight(columnCount? : number, options? : { moveToEndOfSelection? : void }) : void;
    
        /**
         * Moves the cursor to the top of the buffer. 
         */
        moveToTop() : void;
    
        /**
         * Moves the cursor to the bottom of the buffer. 
         */
        moveToBottom() : void;
    
        /**
         * Moves the cursor to the beginning of the line. 
         */
        moveToBeginningOfScreenLine() : void;
    
        /**
         * Moves the cursor to the beginning of the buffer line. 
         */
        moveToBeginningOfLine() : void;
    
        /**
         * Moves the cursor to the beginning of the first character in the
         * line. 
         */
        moveToFirstCharacterOfLine() : void;
    
        /**
         * Moves the cursor to the end of the line. 
         */
        moveToEndOfScreenLine() : void;
    
        /**
         * Moves the cursor to the end of the buffer line. 
         */
        moveToEndOfLine() : void;
    
        /**
         * Moves the cursor to the beginning of the word. 
         */
        moveToBeginningOfWord() : void;
    
        /**
         * Moves the cursor to the end of the word. 
         */
        moveToEndOfWord() : void;
    
        /**
         * Moves the cursor to the beginning of the next word. 
         */
        moveToBeginningOfNextWord() : void;
    
        /**
         * Moves the cursor to the previous word boundary. 
         */
        moveToPreviousWordBoundary() : void;
    
        /**
         * Moves the cursor to the next word boundary. 
         */
        moveToNextWordBoundary() : void;
    
        /**
         * Moves the cursor to the beginning of the buffer line, skipping all
         * whitespace. 
         */
        skipLeadingWhitespace() : any;
    
        /**
         * Moves the cursor to the beginning of the next paragraph 
         */
        moveToBeginningOfNextParagraph() : void;
    
        /**
         * Moves the cursor to the beginning of the previous paragraph 
         */
        moveToBeginningOfPreviousParagraph() : void;
    
        getPreviousWordBoundaryBufferPosition(options? : any) : TextBuffer.Point;
    
        getNextWordBoundaryBufferPosition(options? : any) : TextBuffer.Point;
    
        /**
         * Retrieves the buffer position of where the current word starts.
         */
        getBeginningOfCurrentWordBufferPosition(options? : any) : TextBuffer.Point;
    
        /**
         * Retrieves the buffer position of where the current word ends.
         */
        getEndOfCurrentWordBufferPosition(options? : any) : TextBuffer.Point;
    
        /**
         * Retrieves the buffer position of where the next word starts.
         */
        getBeginningOfNextWordBufferPosition(options? : any) : TextBuffer.Point;
    
        getCurrentWordBufferRange(options? : Object) : TextBuffer.Range;
    
        getCurrentLineBufferRange(options? : Object) : TextBuffer.Range;
    
        /**
         * Retrieves the range for the current paragraph.
         * 
         * A paragraph is defined as a block of text surrounded by empty lines.
         */
        getCurrentParagraphBufferRange() : TextBuffer.Range;
    
        getCurrentWordPrefix() : any;
    
        /**
         * Sets whether the cursor is visible. 
         */
        setVisible(visible? : boolean) : void;
    
        isVisible() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateVisibility() : void;
    
        /**
         * Compare this cursor's buffer position to another cursor's buffer position.
         * 
         * See {Point::compare} for more details.
         * @param otherCursor? - {Cursor} to compare against 
         */
        compare(otherCursor? : Cursor) : any;
    
        /**
         * Prevents this cursor from causing scrolling. 
         */
        clearAutoscroll() : any;
    
        /**
         * Deselects the current selection. 
         */
        clearSelection(options? : any) : Selection;
    
        /**
         * Get the RegExp used by the cursor to determine what a "word" is.
        Returns a {RegExp}.
         */
        wordRegExp(includeNonWordCharacters? : any) : RegExp;
    
        /**
         * Private
         * This field or method was marked private by atomdoc. Use with caution.
         */
        changePosition(options? : any, fn? : any) : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getPixelRect() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getScreenRange() : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        autoscroll(options? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getBeginningOfNextParagraphBufferPosition() : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getBeginningOfPreviousParagraphBufferPosition() : TextBuffer.Point;
    
    }

    /**
     * CursorsComponent
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class CursorsComponent {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        oldState: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor();
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateSync(state? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateCursorNode(id? : any, newCursorState? : any) : void;
    
    }

    /**
     * Represents a decoration that follows a {Marker}. A decoration is
     * basically a visual representation of a marker. It allows you to add CSS
     * classes to line numbers in the gutter, lines, and add selection-line regions
     * around marked ranges of text.
     */
    class Decoration {
        /**
         * Check if the `decorationProperties.type` matches `type`
         * This field or method was marked private by atomdoc. Use with caution.
         * @param decorationProperties? - {Object} eg. `{type: 'line-number', class: 'my-new-class'}`
         * @param type? - {String} type like `'line-number'`, `'line'`, etc. `type` can also be an {Array} of {String}s, where it will return true if the decoration's type matches any in the array.
         */
        static isType(decorationProperties? : Object, type? : string) : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        marker: Marker;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        displayBuffer: DisplayBuffer;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        properties: any /* default */;
    
        /**
         * Construction and Destruction
         * This field or method was marked private by atomdoc. Use with caution.
         */
        constructor(marker? : Marker, displayBuffer? : DisplayBuffer, properties? : any);
    
        /**
         * Destroy this marker.
         * 
         * If you own the marker, you should use {Marker::destroy} which will destroy
         * this decoration. 
         */
        destroy() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isDestroyed() : boolean;
    
        /**
         * When the {Decoration} is updated via {Decoration::update}.
         * @param callback? - {Function}
         */
        onDidChangeProperties(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when the {Decoration} is destroyed
         * @param callback? - {Function}
         */
        onDidDestroy(callback? : Function) : EventKit.Disposable;
    
        /**
         * An id unique across all {Decoration} objects 
         */
        getId() : any;
    
        getMarker() : Marker;
    
        /**
         * Check if the `decorationProperties.type` matches `type`
         * This field or method was marked private by atomdoc. Use with caution.
         * @param type? - {String} type like `'line-number'`, `'line'`, etc. `type` can also be an {Array} of {String}s, where it will return true if the decoration's type matches any in the array.
         */
        isType(type? : string) : boolean;
    
        getProperties() : Decoration;
    
        /**
         * Update the marker with new Properties. Allows you to change the decoration's class.
         * @param newProperties? - {Object} eg. `{type: 'line-number', class: 'my-new-class'}` 
         */
        setProperties(newProperties? : Object) : void;
    
        /**
         * Private methods
         * This field or method was marked private by atomdoc. Use with caution.
         */
        matchesPattern(decorationPattern? : FirstMate.Pattern) : FirstMate.Pattern;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidFlash(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        flash(klass? : any, duration? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        consumeNextFlash() : any;
    
    }

    /**
     * DefaultDirectoryProvider
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class DefaultDirectoryProvider {
        /**
         * Create a Directory that corresponds to the specified URI.
         * @param uri? - {String} The path to the directory to add. This is guaranteed not to be contained by a {Directory} in `atom.project`.
        Returns:

* {Directory} if the given URI is compatible with this provider.
* `null` if the given URI is not compatibile with this provider.
         */
        directoryForURISync(uri? : string) : Pathwatcher.Directory;
    
        /**
         * Create a Directory that corresponds to the specified URI.
         * @param uri? - {String} The path to the directory to add. This is guaranteed not to be contained by a {Directory} in `atom.project`.
        Returns a Promise that resolves to:

* {Directory} if the given URI is compatible with this provider.
* `null` if the given URI is not compatibile with this provider.
         */
        directoryForURI(uri? : string) : Pathwatcher.Directory;
    
    }

    /**
     * Manages the deserializers used for serialized state
     */
    class DeserializerManager {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor();
    
        /**
         * Register the given class(es) as deserializers.
         */
        add(deserializers? : any) : any;
    
        /**
         * Deserialize the state and params.
         * @param state? - The state {Object} to deserialize.
         * @param params? - The params {Object} to pass as the second arguments to the deserialize method of the deserializer. 
         */
        deserialize(state? : Object, params? : Object) : any;
    
        /**
         * Get the deserializer for the state.
         * This field or method was marked private by atomdoc. Use with caution.
         * @param state? - The state {Object} being deserialized. 
         */
        get(state? : Object) : any;
    
    }

    /**
     * BufferToScreenConversionError
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class BufferToScreenConversionError /*extends Error*/ {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        message: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        metadata: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(message? : any, metadata? : any);
    
    }

    /**
     * DisplayBuffer
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class DisplayBuffer extends Model {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        editorWidthInChars: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        tokenizedBuffer: TokenizedBuffer;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        invisibles: boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        verticalScrollMargin: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        horizontalScrollMargin: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        scopedCharacterWidthsChangeCount: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(tabLength? : any, editorWidthInChars? : any, tokenizedBuffer? : TokenizedBuffer, buffer? : any, invisibles? : boolean);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        subscribeToScopedConfigSettings() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        serializeParams() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        deserializeParams(params? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        copy() : DisplayBuffer;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateAllScreenLines() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidChangeSoftWrapped(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidChangeGrammar(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidTokenize(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidChange(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidChangeCharacterWidths(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidChangeScrollTop(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidChangeScrollLeft(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        observeScrollTop(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        observeScrollLeft(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        observeDecorations(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidAddDecoration(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidRemoveDecoration(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidCreateMarker(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidUpdateMarkers(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        emitDidChange(eventProperties? : any, refreshMarkers? : Marker[]) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateWrappedScreenLines() : void;
    
        /**
         * Sets the visibility of the tokenized buffer.
         * 
         * visible - A {Boolean} indicating of the tokenized buffer is shown 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        setVisible(visible? : boolean) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getVerticalScrollMargin() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setVerticalScrollMargin(verticalScrollMargin? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getVerticalScrollMarginInPixels() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getHorizontalScrollMargin() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setHorizontalScrollMargin(horizontalScrollMargin? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getHorizontalScrollMarginInPixels() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getHorizontalScrollbarHeight() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setHorizontalScrollbarHeight(horizontalScrollbarHeight? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getVerticalScrollbarWidth() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setVerticalScrollbarWidth(verticalScrollbarWidth? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getHeight() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setHeight(height? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getClientHeight(reentrant? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getClientWidth(reentrant? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        horizontallyScrollable(reentrant? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        verticallyScrollable(reentrant? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getWidth() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setWidth(newWidth? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getScrollTop() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setScrollTop(scrollTop? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getMaxScrollTop() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getScrollBottom() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setScrollBottom(scrollBottom? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getScrollLeft() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setScrollLeft(scrollLeft? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getMaxScrollLeft() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getScrollRight() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setScrollRight(scrollRight? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getLineHeightInPixels() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setLineHeightInPixels(lineHeightInPixels? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getDefaultCharWidth() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setDefaultCharWidth(defaultCharWidth? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getCursorWidth() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getScopedCharWidth(scopeNames? : string, char? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getScopedCharWidths(scopeNames? : string) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        batchCharacterMeasurement(fn? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setScopedCharWidth(scopeNames? : string, char? : any, width? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        characterWidthsChanged() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        clearScopedCharWidths() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getScrollHeight() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getScrollWidth() : any;
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getVisibleRowRange() : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        intersectsVisibleRowRange(startRow? : number, endRow? : number) : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        selectionIntersectsVisibleRowRange(selection? : Range) : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        scrollToScreenRange(screenRange? : TextBuffer.Range, options? : any) : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        scrollToScreenPosition(screenPosition? : TextBuffer.Point | { row: number; column: number } | [number, number], options? : any) : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        scrollToBufferPosition(bufferPosition? : TextBuffer.Point | { row: number; column: number } | [number, number], options? : any) : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pixelRectForScreenRange(screenRange? : TextBuffer.Range) : TextBuffer.Range;
    
        /**
         * Retrieves the current tab length.
         * This field or method was marked private by atomdoc. Use with caution.
        Returns a {Number}.
         */
        getTabLength() : number;
    
        /**
         * Specifies the tab length.
         * 
         * tabLength - A {Number} that defines the new tab length. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        setTabLength(tabLength? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setInvisibles(invisibles? : boolean) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setSoftWrapped(softWrapped? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isSoftWrapped() : boolean;
    
        /**
         * Set the number of characters that fit horizontally in the editor.
         * 
         * editorWidthInChars - A {Number} of characters. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        setEditorWidthInChars(editorWidthInChars? : any) : void;
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
        Returns the editor width in characters for soft wrap.
         */
        getEditorWidthInChars() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getSoftWrapColumn() : number;
    
        /**
         * Gets the screen line for the given screen row.
         * This field or method was marked private by atomdoc. Use with caution.
         * @param screenRow? - A {Number} indicating the screen row.
         */
        tokenizedLineForScreenRow(screenRow? : number) : TokenizedLine;
    
        /**
         * Gets the screen lines for the given screen row range.
         * 
         * startRow - A {Number} indicating the beginning screen row.
         * endRow - A {Number} indicating the ending screen row.
         * This field or method was marked private by atomdoc. Use with caution.
         */
        tokenizedLinesForScreenRows(startRow? : number, endRow? : number) : TokenizedLine[];
    
        /**
         * Gets all the screen lines.
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getTokenizedLines() : TokenizedLine[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        indentLevelForLine(line? : any) : any;
    
        /**
         * Given starting and ending screen rows, this returns an array of the
         * buffer rows corresponding to every screen row in the range
         * 
         * startScreenRow - The screen row {Number} to start at
         * endScreenRow - The screen row {Number} to end at (default: the last screen row)
         * This field or method was marked private by atomdoc. Use with caution.
         */
        bufferRowsForScreenRows(startScreenRow? : number, endScreenRow? : number) : number[];
    
        /**
         * Creates a new fold between two row numbers.
         * 
         * startRow - The row {Number} to start folding at
         * endRow - The row {Number} to end the fold
         * This field or method was marked private by atomdoc. Use with caution.
         */
        createFold(startRow? : number, endRow? : number) : Fold;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isFoldedAtBufferRow(bufferRow? : number) : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isFoldedAtScreenRow(screenRow? : number) : boolean;
    
        /**
         * Destroys the fold with the given id 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        destroyFoldWithId(id? : any) : void;
    
        /**
         * Removes any folds found that contain the given buffer row.
         * 
         * bufferRow - The buffer row {Number} to check against 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        unfoldBufferRow(bufferRow? : number) : number;
    
        /**
         * Given a buffer row, this returns the largest fold that starts there.
         * 
         * Largest is defined as the fold whose difference between its start and end points
         * are the greatest.
         * 
         * bufferRow - A {Number} indicating the buffer row
         * This field or method was marked private by atomdoc. Use with caution.
         */
        largestFoldStartingAtBufferRow(bufferRow? : number) : number;
    
        /**
         * Given a buffer row, this returns all folds that start there.
         * 
         * bufferRow - A {Number} indicating the buffer row
         */
        foldsStartingAtBufferRow(bufferRow? : number) : number;
    
        /**
         * Given a screen row, this returns the largest fold that starts there.
         * 
         * Largest is defined as the fold whose difference between its start and end points
         * are the greatest.
         * 
         * screenRow - A {Number} indicating the screen row
         * This field or method was marked private by atomdoc. Use with caution.
         */
        largestFoldStartingAtScreenRow(screenRow? : number) : number;
    
        /**
         * Given a buffer row, this returns the largest fold that includes it.
         * 
         * Largest is defined as the fold whose difference between its start and end rows
         * is the greatest.
         * 
         * bufferRow - A {Number} indicating the buffer row
         * This field or method was marked private by atomdoc. Use with caution.
         */
        largestFoldContainingBufferRow(bufferRow? : number) : number;
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        outermostFoldsInBufferRowRange(startRow? : number, endRow? : number) : TextBuffer.Range;
    
        /**
         * Given a buffer row, this returns folds that include it.
         * 
         * bufferRow - A {Number} indicating the buffer row
         */
        foldsContainingBufferRow(bufferRow? : number) : number;
    
        /**
         * Given a buffer row, this converts it into a screen row.
         * 
         * bufferRow - A {Number} representing a buffer row
         * This field or method was marked private by atomdoc. Use with caution.
         */
        screenRowForBufferRow(bufferRow? : number) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        lastScreenRowForBufferRow(bufferRow? : number) : number;
    
        /**
         * Given a screen row, this converts it into a buffer row.
         * 
         * screenRow - A {Number} representing a screen row
         * This field or method was marked private by atomdoc. Use with caution.
         */
        bufferRowForScreenRow(screenRow? : number) : number;
    
        /**
         * Given a buffer range, this converts it into a screen position.
         * 
         * bufferRange - The {Range} to convert
         * This field or method was marked private by atomdoc. Use with caution.
         */
        screenRangeForBufferRange(bufferRange? : TextBuffer.Range, options? : any) : TextBuffer.Range;
    
        /**
         * Given a screen range, this converts it into a buffer position.
         * 
         * screenRange - The {Range} to convert
         * This field or method was marked private by atomdoc. Use with caution.
         */
        bufferRangeForScreenRange(screenRange? : TextBuffer.Range) : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pixelRangeForScreenRange(screenRange? : TextBuffer.Range, clip? : any) : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pixelPositionForScreenPosition(screenPosition? : TextBuffer.Point | { row: number; column: number } | [number, number], clip? : any) : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        screenPositionForPixelPosition(pixelPosition? : TextBuffer.Point | { row: number; column: number } | [number, number]) : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pixelPositionForBufferPosition(bufferPosition? : TextBuffer.Point | { row: number; column: number } | [number, number]) : TextBuffer.Point;
    
        /**
         * Gets the number of screen lines.
         * This field or method was marked private by atomdoc. Use with caution.
        Returns a {Number}.
         */
        getLineCount() : number;
    
        /**
         * Gets the number of the last screen line.
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getLastRow() : number;
    
        /**
         * Gets the length of the longest screen line.
         * This field or method was marked private by atomdoc. Use with caution.
        Returns a {Number}.
         */
        getMaxLineLength() : number;
    
        /**
         * Gets the row number of the longest screen line.
         * 
         * Return a {} 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getLongestScreenRow() : number;
    
        /**
         * Given a buffer position, this converts it into a screen position.
         * 
         * bufferPosition - An object that represents a buffer position. It can be either
         *                  an {Object} (`{row, column}`), {Array} (`[row, column]`), or {Point}
         * options - A hash of options with the following keys:
         *           wrapBeyondNewlines:
         *           wrapAtSoftNewlines:
         * This field or method was marked private by atomdoc. Use with caution.
         */
        screenPositionForBufferPosition(bufferPosition? : TextBuffer.Point | { row: number; column: number } | [number, number], options? : any) : TextBuffer.Point;
    
        /**
         * Given a buffer position, this converts it into a screen position.
         * 
         * screenPosition - An object that represents a buffer position. It can be either
         *                  an {Object} (`{row, column}`), {Array} (`[row, column]`), or {Point}
         * options - A hash of options with the following keys:
         *           wrapBeyondNewlines:
         *           wrapAtSoftNewlines:
         * This field or method was marked private by atomdoc. Use with caution.
         */
        bufferPositionForScreenPosition(screenPosition? : TextBuffer.Point | { row: number; column: number } | [number, number], options? : any) : TextBuffer.Point;
    
        /**
         * Retrieves the grammar's token scopeDescriptor for a buffer position.
         * 
         * bufferPosition - A {Point} in the {TextBuffer}
         * This field or method was marked private by atomdoc. Use with caution.
         */
        scopeDescriptorForBufferPosition(bufferPosition? : TextBuffer.Point | { row: number; column: number } | [number, number]) : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        bufferRangeForScopeAtPosition(selector? : ScopedPropertyStore.Selector, position? : TextBuffer.Point | { row: number; column: number } | [number, number]) : TextBuffer.Range;
    
        /**
         * Retrieves the grammar's token for a buffer position.
         * 
         * bufferPosition - A {Point} in the {TextBuffer}.
         * This field or method was marked private by atomdoc. Use with caution.
         */
        tokenForBufferPosition(bufferPosition? : TextBuffer.Point | { row: number; column: number } | [number, number]) : TextBuffer.Point;
    
        /**
         * Get the grammar for this buffer.
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getGrammar() : FirstMate.Grammar;
    
        /**
         * Sets the grammar for the buffer.
         * 
         * grammar - Sets the new grammar rules 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        setGrammar(grammar? : FirstMate.Grammar) : void;
    
        /**
         * Reloads the current grammar. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        reloadGrammar() : FirstMate.Grammar;
    
        /**
         * Given a position, this clips it to a real position.
         * 
         * For example, if `position`'s row exceeds the row count of the buffer,
         * or if its column goes beyond a line's length, this "sanitizes" the value
         * to a real position.
         * 
         * position - The {Point} to clip
         * options - A hash with the following values:
         *           wrapBeyondNewlines: if `true`, continues wrapping past newlines
         *           wrapAtSoftNewlines: if `true`, continues wrapping past soft newlines
         *           skipSoftWrapIndentation: if `true`, skips soft wrap indentation without wrapping to the previous line
         *           screenLine: if `true`, indicates that you're using a line number, not a row number
         * This field or method was marked private by atomdoc. Use with caution.
         */
        clipScreenPosition(screenPosition? : TextBuffer.Point | { row: number; column: number } | [number, number], options? : any) : TextBuffer.Point;
    
        /**
         * Clip the start and end of the given range to valid positions on screen.
         * See {::clipScreenPosition} for more information.
         * This field or method was marked private by atomdoc. Use with caution.
         * @param range? - The {Range} to clip.
         * @param options? - See {::clipScreenPosition} `options`. Returns a {Range}. 
         */
        clipScreenRange(range? : TextBuffer.Range, options? : TextBuffer.Range) : TextBuffer.Range;
    
        /**
         * Calculates a {Range} representing the start of the {TextBuffer} until the end.
         * This field or method was marked private by atomdoc. Use with caution.
         */
        rangeForAllLines() : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        decorationForId(id? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getDecorations(propertyFilter? : any) : Decoration[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getLineDecorations(propertyFilter? : any) : Decoration[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getLineNumberDecorations(propertyFilter? : any) : Decoration[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getHighlightDecorations(propertyFilter? : any) : Decoration[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getOverlayDecorations(propertyFilter? : any) : Decoration[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        decorationsForScreenRowRange(startScreenRow? : number, endScreenRow? : number) : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        decorateMarker(marker? : Marker, decorationParams? : any) : Marker;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        removeDecoration(decoration? : Decoration) : Decoration;
    
        /**
         * Retrieves a {Marker} based on its id.
         * 
         * id - A {Number} representing a marker id
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getMarker(id? : any) : Marker;
    
        /**
         * Retrieves the active markers in the buffer.
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getMarkers() : Marker[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getMarkerCount() : any;
    
        /**
         * Constructs a new marker at the given screen range.
         * 
         * range - The marker {Range} (representing the distance between the head and tail)
         * options - Options to pass to the {Marker} constructor
         */
        markScreenRange(args? : any) : TextBuffer.Range;
    
        /**
         * Constructs a new marker at the given buffer range.
         * 
         * range - The marker {Range} (representing the distance between the head and tail)
         * options - Options to pass to the {Marker} constructor
         */
        markBufferRange(range? : TextBuffer.Range, options? : any) : TextBuffer.Range;
    
        /**
         * Constructs a new marker at the given screen position.
         * 
         * range - The marker {Range} (representing the distance between the head and tail)
         * options - Options to pass to the {Marker} constructor
         */
        markScreenPosition(screenPosition? : TextBuffer.Point | { row: number; column: number } | [number, number], options? : any) : TextBuffer.Point;
    
        /**
         * Constructs a new marker at the given buffer position.
         * 
         * range - The marker {Range} (representing the distance between the head and tail)
         * options - Options to pass to the {Marker} constructor
         */
        markBufferPosition(bufferPosition? : TextBuffer.Point | { row: number; column: number } | [number, number], options? : any) : TextBuffer.Point;
    
        /**
         * Removes the marker with the given id.
         * 
         * id - The {Number} of the ID to remove 
         */
        destroyMarker(id? : any) : void;
    
        /**
         * Finds the first marker satisfying the given attributes
         * 
         * Refer to {DisplayBuffer::findMarkers} for details.
         * This field or method was marked private by atomdoc. Use with caution.
         */
        findMarker(params? : any) : Marker;
    
        /**
         * Find all markers satisfying a set of parameters.
         * 
         * params - An {Object} containing parameters that all returned markers must
         *   satisfy. Unreserved keys will be compared against the markers' custom
         *   properties. There are also the following reserved keys with special
         *   meaning for the query:
         *   :startBufferRow - A {Number}. Only returns markers starting at this row in
         *     buffer coordinates.
         *   :endBufferRow - A {Number}. Only returns markers ending at this row in
         *     buffer coordinates.
         *   :containsBufferRange - A {Range} or range-compatible {Array}. Only returns
         *     markers containing this range in buffer coordinates.
         *   :containsBufferPosition - A {Point} or point-compatible {Array}. Only
         *     returns markers containing this position in buffer coordinates.
         *   :containedInBufferRange - A {Range} or range-compatible {Array}. Only
         *     returns markers contained within this range.
         */
        findMarkers(params? : any) : Marker[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        translateToBufferMarkerParams(params? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        findFoldMarker(attributes? : any) : Marker;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        findFoldMarkers(attributes? : any) : Marker[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getFoldMarkerAttributes(attributes? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pauseMarkerChangeEvents() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        resumeMarkerChangeEvents() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        refreshMarkerScreenPositions() : TextBuffer.Point[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        destroyed() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        logLines(start? : any, end? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getRootScopeDescriptor() : ScopeDescriptor;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        handleTokenizedBufferChange(tokenizedBufferChange? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateScreenLines(startBufferRow? : number, endBufferRow? : number, bufferDelta? : any, options? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildScreenLines(startBufferRow? : number, endBufferRow? : number) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        findMaxLineLength(startScreenRow? : number, endScreenRow? : number, newScreenLines? : any, screenDelta? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        computeScrollWidth() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        handleBufferMarkersUpdated() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        handleBufferMarkerCreated(textBufferMarker? : Marker) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        createFoldForMarker(marker? : Marker) : Marker;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        foldForMarker(marker? : Marker) : Marker;
    
    }

    /**
     * Represents a fold that collapses multiple buffer lines into a single
     * line on the screen.
     */
    class Fold {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        id: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        displayBuffer: DisplayBuffer;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        marker: Marker;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(displayBuffer? : DisplayBuffer, marker? : Marker);
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        isInsideLargerFold() : boolean;
    
        /**
         * Destroys this fold 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        destroy() : void;
    
        /**
         * 
         * 
         * includeNewline - A {Boolean} which, if `true`, includes the trailing newline
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getBufferRange(includeNewline? : any) : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getBufferRowRange() : TextBuffer.Range;
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getStartRow() : number;
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getEndRow() : number;
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
        Returns a {String} representation of the fold.
         */
        inspect() : string;
    
        /**
         * Retrieves the number of buffer rows spanned by the fold.
         * This field or method was marked private by atomdoc. Use with caution.
        Returns a {Number}.
         */
        getBufferRowCount() : number;
    
        /**
         * Identifies if a fold is nested within a fold.
         * 
         * fold - A {Fold} to check
         * This field or method was marked private by atomdoc. Use with caution.
         */
        isContainedByFold(fold? : Fold) : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateDisplayBuffer() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        destroyed() : void;
    
    }

    /**
     * Provider that conforms to the atom.repository-provider@0.1.0 service. 
     */
    class GitRepositoryProvider {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        project: Project;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(project? : Project);
    
        /**
         * 
         * 
         * * {GitRepository} if the given directory has a Git repository.
         * * `null` if the given directory does not have a Git repository. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        repositoryForDirectory(directory? : Pathwatcher.Directory) : Pathwatcher.Directory;
    
        /**
         * 
         * 
         * * {GitRepository} if the given directory has a Git repository.
         * * `null` if the given directory does not have a Git repository. 
         * This field or method was marked private by atomdoc. Use with caution.
        Returns either:
         */
        repositoryForDirectorySync(directory? : Pathwatcher.Directory) : any;
    
    }

    /**
     * Represents the underlying git operations performed by Atom.
     */
    export class GitRepository {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static exists(path? : any) : any;
    
        /**
         * Creates a new GitRepository instance.
         * @param path? - The {String} path to the Git repository to open.
         * @param options? - An optional {Object} with the following keys:
        Returns a {GitRepository} instance or `null` if the repository could not be opened.
         */
        static open(path? : string, options? : Object) : GitRepository;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(path? : any, options? : any);
    
        /**
         * Destroy this {GitRepository} object.
         * 
         * This destroys any tasks and subscriptions and releases the underlying
         * libgit2 repository handle. This method is idempotent. 
         */
        destroy() : void;
    
        /**
         * Invoke the given callback when this GitRepository's destroy() method
         * is invoked. 
         */
        onDidDestroy(callback? : any) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when a specific file's status has
         * changed. When a file is updated, reloaded, etc, and the status changes, this
         * will be fired.
         * @param callback? - {Function}
         */
        onDidChangeStatus(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when a multiple files' statuses have
         * changed. For example, on window focus, the status of all the paths in the
         * repo is checked. If any of them have changed, this will be fired. Call
         * {::getPathStatus(path)} to get the status for your path of choice.
         * @param callback? - {Function}
         */
        onDidChangeStatuses(callback? : Function) : EventKit.Disposable;
    
        /**
         * A {String} indicating the type of version control system used by
         * this repository.
        Returns `"git"`.
         */
        getType() : any;
    
        getPath() : string;
    
        getWorkingDirectory() : Pathwatcher.Directory;
    
        isProjectAtRoot() : boolean;
    
        /**
         * Makes a path relative to the repository's working directory. 
         */
        relativize(path? : any) : any;
    
        hasBranch(branch? : any) : any;
    
        /**
         * Retrieves a shortened version of the HEAD reference value.
         * 
         * This removes the leading segments of `refs/heads`, `refs/tags`, or
         * `refs/remotes`.  It also shortens the SHA-1 of a detached `HEAD` to 7
         * characters.
         * @param path? - An optional {String} path in the repository to get this information for, only needed if the repository contains submodules.
        Returns a {String}.
         */
        getShortHead(path? : string) : string;
    
        /**
         * Is the given path a submodule in the repository?
         * @param path? - The {String} path to check.
         */
        isSubmodule(path? : string) : boolean;
    
        getAheadBehindCount(reference? : string, path? : string) : any;
    
        /**
         * Get the cached ahead/behind commit counts for the current branch's
         * upstream branch.
         * @param path? - An optional {String} path in the repository to get this information for, only needed if the repository has submodules.
        Returns an {Object} with the following keys:

* `ahead`  The {Number} of commits ahead.
* `behind` The {Number} of commits behind.
         */
        getCachedUpstreamAheadBehindCount(path? : string) : Object;
    
        getConfigValue(key? : any, path? : string) : any;
    
        getOriginURL(path? : string) : any;
    
        getUpstreamBranch(path? : string) : any | string;
    
        /**
         * Gets all the local and remote references.
         * @param path? - An optional {String} path in the repository to get this information for, only needed if the repository has submodules.
        Returns an {Object} with the following keys:

* `heads`   An {Array} of head reference names.
* `remotes` An {Array} of remote reference names.
* `tags`    An {Array} of tag reference names.
         */
        getReferences(path? : string) : Object;
    
        getReferenceTarget(reference? : string, path? : string) : string;
    
        isPathModified(path? : any) : boolean;
    
        isPathNew(path? : any) : boolean;
    
        /**
         * Is the given path ignored?
         */
        isPathIgnored(path? : any) : boolean;
    
        /**
         * Get the status of a directory in the repository's working directory.
        Returns a {Number} representing the status. This value can be passed to
{::isStatusModified} or {::isStatusNew} to get more information.
         */
        getDirectoryStatus(directoryPath? : any) : number;
    
        /**
         * Get the status of a single path in the repository.
         * 
         * `path` A {String} repository-relative path.
        Returns a {Number} representing the status. This value can be passed to
{::isStatusModified} or {::isStatusNew} to get more information.
         */
        getPathStatus(path? : any) : number;
    
        /**
         * Get the cached status for the given path.
         * @param path? - A {String} path in the repository, relative or absolute.
        Returns a status {Number} or null if the path is not in the cache.
         */
        getCachedPathStatus(path? : string) : number;
    
        isStatusModified(status? : any) : boolean;
    
        isStatusNew(status? : any) : boolean;
    
        /**
         * Retrieves the number of lines added and removed to a path.
         * 
         * This compares the working directory contents of the path to the `HEAD`
         * version.
         * @param path? - The {String} path to check.
        Returns an {Object} with the following keys:

* `added` The {Number} of added lines.
* `deleted` The {Number} of deleted lines.
         */
        getDiffStats(path? : string) : Object;
    
        /**
         * Retrieves the line diffs comparing the `HEAD` version of the given
         * path and the given text.
         * @param path? - The {String} path relative to the repository.
         * @param text? - The {String} to compare against the `HEAD` contents
        Returns an {Array} of hunk {Object}s with the following keys:

* `oldStart` The line {Number} of the old hunk.
* `newStart` The line {Number} of the new hunk.
* `oldLines` The {Number} of lines in the old hunk.
* `newLines` The {Number} of lines in the new hunk
         */
        getLineDiffs(path? : string, text? : string) : any[];
    
        /**
         * Restore the contents of a path in the working directory and index
         * to the version at `HEAD`.
         * 
         * This is essentially the same as running:
         * 
         * ```sh
         *   git reset HEAD -- <path>
         *   git checkout HEAD -- <path>
         * ```
         * @param path? - The {String} path to checkout.
        Returns a {Boolean} that's true if the method was successful.
         */
        checkoutHead(path? : string) : boolean;
    
        /**
         * Checks out a branch in your repository.
         * @param reference? - The {String} reference to checkout.
         * @param create? - A {Boolean} value which, if true creates the new reference if it doesn't exist.
        Returns a Boolean that's true if the method was successful.
         */
        checkoutReference(reference? : string, create? : boolean) : any;
    
        /**
         * Subscribes to buffer events. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        subscribeToBuffer(buffer? : any) : any;
    
        /**
         * Subscribes to editor view event. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        checkoutHeadForEditor(editor? : TextEditor) : any;
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
        Returns the corresponding {Repository}
         */
        getRepo(path? : any) : any;
    
        /**
         * Reread the index to update any values that have changed since the
         * last time the index was read. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        refreshIndex() : any;
    
        /**
         * Refreshes the current git status in an outside process and asynchronously
         * updates the relevant properties. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        refreshStatus() : any;
    
    }

    /**
     * Syntax class holding the grammars used for tokenizing.
     */
    class GrammarRegistry extends FirstMate.GrammarRegistry {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static deserialize(grammarOverridesByPath? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor();
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        serialize() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        createToken(value? : any, scopes? : Token[]) : Token;
    
        /**
         * Select a grammar for the given file path and file contents.
         * 
         * This picks the best match by checking the file path and contents against
         * each grammar.
         * @param filePath? - A {String} file path.
         * @param fileContents? - A {String} of text for the file path.
         */
        selectGrammar(filePath? : string, fileContents? : string) : FirstMate.Grammar;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        clearObservers() : any;
    
    }

    /**
     * GutterComponent
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class GutterComponent {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        presenter: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        editor: Atom.TextEditor;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        dummyLineNumberNode: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(presenter? : any, onMouseDown? : any, editor? : TextEditor);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateSync(state? : any) : void;
    
        /**
         * This dummy line number element holds the gutter to the appropriate width,
         * since the real line numbers are absolutely positioned for performance reasons. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        appendDummyLineNumber() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateDummyLineNumber() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateLineNumbers() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildLineNumberHTML(lineNumberState? : any) : string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildLineNumberInnerHTML(bufferRow? : number, softWrapped? : any) : string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateLineNumberNode(lineNumberId? : any, newLineNumberState? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildLineNumberClassName(bufferRow? : number, foldable? : any, decorationClasses? : any, softWrapped? : any) : string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        lineNumberNodeForScreenRow(screenRow? : number) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onMouseDown(event? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onClick(event? : any) : any;
    
    }

    /**
     * HighlightsComponent
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class HighlightsComponent {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        oldState: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor();
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateSync(state? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateHighlightNode(id? : any, newHighlightState? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateHighlightRegions(id? : any, newHighlightState? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        flashHighlightNodeIfRequested(id? : any, newHighlightState? : any) : any;
    
    }

    /**
     * InputComponent
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class InputComponent {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor();
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateSync(state? : any) : void;
    
    }

    /**
     * ItemRegistry
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class ItemRegistry {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor();
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        addItem(item? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        removeItem(item? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        hasItem(item? : any) : any;
    
    }

    /**
     * LanguageMode
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class LanguageMode {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        editor: Atom.TextEditor;
    
        /**
         * Sets up a `LanguageMode` for the given {TextEditor}.
         * 
         * editor - The {TextEditor} to associate with 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        constructor(editor? : TextEditor);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        destroy() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        toggleLineCommentForBufferRow(row? : number) : number;
    
        /**
         * Wraps the lines between two rows in comments.
         * 
         * If the language doesn't have comment, nothing happens.
         * 
         * startRow - The row {Number} to start at
         * endRow - The row {Number} to end at 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        toggleLineCommentsForBufferRows(start? : any, end? : any) : number[];
    
        /**
         * Folds all the foldable lines in the buffer. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        foldAll() : any;
    
        /**
         * Unfolds all the foldable lines in the buffer. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        unfoldAll() : any;
    
        /**
         * Fold all comment and code blocks at a given indentLevel
         * 
         * indentLevel - A {Number} indicating indentLevel; 0 based. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        foldAllAtIndentLevel(indentLevel? : any) : any;
    
        /**
         * Given a buffer row, creates a fold at it.
         * 
         * bufferRow - A {Number} indicating the buffer row
         * This field or method was marked private by atomdoc. Use with caution.
         */
        foldBufferRow(bufferRow? : number) : number;
    
        /**
         * Find the row range for a fold at a given bufferRow. Will handle comments
         * and code.
         * 
         * bufferRow - A {Number} indicating the buffer row
         * This field or method was marked private by atomdoc. Use with caution.
         */
        rowRangeForFoldAtBufferRow(bufferRow? : number) : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        rowRangeForCommentAtBufferRow(bufferRow? : number) : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        rowRangeForCodeFoldAtBufferRow(bufferRow? : number) : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isFoldableAtBufferRow(bufferRow? : number) : boolean;
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        isLineCommentedAtBufferRow(bufferRow? : number) : boolean;
    
        /**
         * Find a row range for a 'paragraph' around specified bufferRow. A paragraph
         * is a block of text bounded by and empty line or a block of text that is not
         * the same type (comments next to source code). 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        rowRangeForParagraphAtBufferRow(bufferRow? : number) : TextBuffer.Range;
    
        /**
         * Given a buffer row, this returns a suggested indentation level.
         * 
         * The indentation level provided is based on the current {LanguageMode}.
         * 
         * bufferRow - A {Number} indicating the buffer row
         * This field or method was marked private by atomdoc. Use with caution.
         */
        suggestedIndentForBufferRow(bufferRow? : number, options? : any) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        suggestedIndentForLineAtBufferRow(bufferRow? : number, line? : any, options? : any) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        suggestedIndentForTokenizedLineAtBufferRow(bufferRow? : number, tokenizedLine? : TokenizedLine, options? : any) : number;
    
        /**
         * Calculate a minimum indent level for a range of lines excluding empty lines.
         * 
         * startRow - The row {Number} to start at
         * endRow - The row {Number} to end at
         * This field or method was marked private by atomdoc. Use with caution.
         */
        minIndentLevelForRowRange(startRow? : number, endRow? : number) : TextBuffer.Range;
    
        /**
         * Indents all the rows between two buffer row numbers.
         * 
         * startRow - The row {Number} to start at
         * endRow - The row {Number} to end at 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        autoIndentBufferRows(startRow? : number, endRow? : number) : number[];
    
        /**
         * Given a buffer row, this indents it.
         * 
         * bufferRow - The row {Number}.
         * options - An options {Object} to pass through to {TextEditor::setIndentationForBufferRow}. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        autoIndentBufferRow(bufferRow? : number, options? : any) : number;
    
        /**
         * Given a buffer row, this decreases the indentation.
         * 
         * bufferRow - The row {Number} 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        autoDecreaseIndentForBufferRow(bufferRow? : number) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getRegexForProperty(scopeDescriptor? : ScopeDescriptor, property? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        increaseIndentRegexForScopeDescriptor(scopeDescriptor? : ScopeDescriptor) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        decreaseIndentRegexForScopeDescriptor(scopeDescriptor? : ScopeDescriptor) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        foldEndRegexForScopeDescriptor(scopeDescriptor? : ScopeDescriptor) : ScopeDescriptor;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        commentStartAndEndStringsForScope(scope? : Scope) : Scope;
    
    }

    /**
     * {LessCache} wrapper used by {ThemeManager} to read stylesheets. 
     */
    class LessCompileCache {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static cacheDir() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(resourcePath? : any, importPaths? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setImportPaths(importPaths? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        read(stylesheetPath? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        cssForFile(stylesheetPath? : any, lessContent? : any) : Pathwatcher.File;
    
    }

    /**
     * LinesComponent
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class LinesComponent {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        presenter: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        hostElement: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        useShadowDOM: boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        placeholderTextDiv: string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(presenter? : any, hostElement? : any, useShadowDOM? : boolean, visible? : boolean);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateSync(state? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        removeLineNodes() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        removeLineNode(id? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateLineNodes() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildLineHTML(id? : any) : string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildEmptyLineInnerHTML(id? : any) : string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildLineInnerHTML(id? : any) : string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildEndOfLineHTML(id? : any) : string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateScopeStack(scopeStack? : any, desiredScopeDescriptor? : ScopeDescriptor) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        popScope(scopeStack? : any) : Scope;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pushScope(scopeStack? : any, scope? : Scope) : Scope;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateLineNode(id? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        lineNodeForScreenRow(screenRow? : number) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        measureLineHeightAndDefaultCharWidth() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        remeasureCharacterWidths() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        measureCharactersInNewLines() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        measureCharactersInLine(lineId? : any, tokenizedLine? : TokenizedLine, lineNode? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        clearScopedCharWidths() : any;
    
    }

    /**
     * Represents a buffer annotation that remains logically stationary
     * even as the buffer changes. This is used to represent cursors, folds, snippet
     * targets, misspelled words, and anything else that needs to track a logical
     * location in the buffer over time.
     */
    class Marker {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        bufferMarker: Marker;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        displayBuffer: DisplayBuffer;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        bufferMarkerSubscription: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        oldHeadBufferPosition: TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        oldHeadScreenPosition: TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        oldTailBufferPosition: TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        oldTailScreenPosition: TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        wasValid: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        deferredChangeEvents: any /* default */;
    
        /**
         * Construction and Destruction
         * This field or method was marked private by atomdoc. Use with caution.
         */
        constructor(bufferMarker? : Marker, displayBuffer? : DisplayBuffer);
    
        /**
         * Destroys the marker, causing it to emit the 'destroyed' event. Once
         * destroyed, a marker cannot be restored by undo/redo operations. 
         */
        destroy() : void;
    
        /**
         * Creates and returns a new {Marker} with the same properties as this
         * marker.
         * @param properties? - {Object} 
         */
        copy(properties? : Object) : Marker;
    
        /**
         * Invoke the given callback when the state of the marker changes.
         * @param callback? - {Function} to be called when the marker changes.
         */
        onDidChange(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when the marker is destroyed.
         * @param callback? - {Function} to be called when the marker is destroyed.
         */
        onDidDestroy(callback? : Function) : EventKit.Disposable;
    
        isValid() : boolean;
    
        isDestroyed() : boolean;
    
        isReversed() : boolean;
    
        /**
         * Get the invalidation strategy for this marker.
         * 
         * Valid values include: `never`, `surround`, `overlap`, `inside`, and `touch`.
        Returns a {String}.
         */
        getInvalidationStrategy() : string;
    
        getProperties() : Object;
    
        /**
         * Merges an {Object} containing new properties into the marker's
         * existing properties.
         * @param properties? - {Object} 
         */
        setProperties(properties? : Object) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        matchesProperties(attributes? : any) : any;
    
        isEqual(other? : Marker) : boolean;
    
        /**
         * Compares this marker to another based on their ranges.
         * @param other? - {Marker}
        Returns a {Number}
         */
        compare(other? : Marker) : number;
    
        /**
         * Gets the buffer range of the display marker.
         */
        getBufferRange() : TextBuffer.Range;
    
        /**
         * Modifies the buffer range of the display marker.
         * @param bufferRange? - The new {Range} to use
         * @param properties? - {Object} properties to associate with the marker.
         */
        setBufferRange(bufferRange? : TextBuffer.Range, properties? : Object) : TextBuffer.Range;
    
        /**
         * Gets the screen range of the display marker.
         */
        getScreenRange() : TextBuffer.Range;
    
        /**
         * Modifies the screen range of the display marker.
         * @param screenRange? - The new {Range} to use
         */
        setScreenRange(screenRange? : TextBuffer.Range, options? : any) : TextBuffer.Range;
    
        /**
         * Retrieves the buffer position of the marker's start. This will always be
         * less than or equal to the result of {Marker::getEndBufferPosition}.
         */
        getStartBufferPosition() : TextBuffer.Point;
    
        /**
         * Retrieves the screen position of the marker's start. This will always be
         * less than or equal to the result of {Marker::getEndScreenPosition}.
         */
        getStartScreenPosition() : TextBuffer.Point;
    
        /**
         * Retrieves the buffer position of the marker's end. This will always be
         * greater than or equal to the result of {Marker::getStartBufferPosition}.
         */
        getEndBufferPosition() : TextBuffer.Point;
    
        /**
         * Retrieves the screen position of the marker's end. This will always be
         * greater than or equal to the result of {Marker::getStartScreenPosition}.
         */
        getEndScreenPosition() : TextBuffer.Point;
    
        /**
         * Retrieves the buffer position of the marker's head.
         */
        getHeadBufferPosition() : TextBuffer.Point;
    
        /**
         * Sets the buffer position of the marker's head.
         * @param bufferPosition? - The new {Point} to use
         * @param properties? - {Object} properties to associate with the marker. 
         */
        setHeadBufferPosition(bufferPosition? : TextBuffer.Point | { row: number; column: number } | [number, number], properties? : Object) : TextBuffer.Point;
    
        /**
         * Retrieves the screen position of the marker's head.
         */
        getHeadScreenPosition() : TextBuffer.Point;
    
        /**
         * Sets the screen position of the marker's head.
         * @param screenPosition? - The new {Point} to use
         * @param properties? - {Object} properties to associate with the marker. 
         */
        setHeadScreenPosition(screenPosition? : TextBuffer.Point | { row: number; column: number } | [number, number], properties? : Object) : TextBuffer.Point;
    
        /**
         * Retrieves the buffer position of the marker's tail.
         */
        getTailBufferPosition() : TextBuffer.Point;
    
        /**
         * Sets the buffer position of the marker's tail.
         * @param bufferPosition? - The new {Point} to use
         */
        setTailBufferPosition(bufferPosition? : TextBuffer.Point | { row: number; column: number } | [number, number]) : TextBuffer.Point;
    
        /**
         * Retrieves the screen position of the marker's tail.
         */
        getTailScreenPosition() : TextBuffer.Point;
    
        /**
         * Sets the screen position of the marker's tail.
         * @param screenPosition? - The new {Point} to use
         */
        setTailScreenPosition(screenPosition? : TextBuffer.Point | { row: number; column: number } | [number, number], options? : any) : TextBuffer.Point;
    
        hasTail() : boolean;
    
        /**
         * Plants the marker's tail at the current head position. After calling
         * the marker's tail position will be its head position at the time of the
         * call, regardless of where the marker's head is moved.
         */
        plantTail() : any;
    
        /**
         * Removes the marker's tail. After calling the marker's head position
         * will be reported as its current tail position until the tail is planted
         * again.
         * @param properties? - {Object} properties to associate with the marker. 
         */
        clearTail(properties? : Object) : any;
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
        Returns a {String} representation of the marker
         */
        inspect() : string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        destroyed() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        notifyObservers(textChanged? : string) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pauseChangeEvents() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        resumeChangeEvents() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getPixelRange() : TextBuffer.Range;
    
    }

    /**
     * Provides a registry for menu items that you'd like to appear in the
     * application menu.
     */
    class MenuManager {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        resourcePath: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(resourcePath? : any);
    
        /**
         * Adds the given items to the application menu.
         * @param items? - An {Array} of menu item {Object}s containing the keys:
        Returns a {Disposable} on which `.dispose()` can be called to remove the
added menu items.
         */
        add(items? : any[]) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        remove(items? : any) : any;
    
        /**
         * Should the binding for the given selector be included in the menu
         * commands.
         * This field or method was marked private by atomdoc. Use with caution.
         * @param selector? - A {String} selector to check.
         */
        includeSelector(selector? : string) : ScopedPropertyStore.Selector;
    
        /**
         * Refreshes the currently visible menu. 
         */
        update() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        loadPlatformItems() : any;
    
        /**
         * Merges an item in a submenu aware way such that new items are always
         * appended to the bottom of existing menus where possible. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        merge(menu? : any, item? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        unmerge(menu? : any, item? : any) : any;
    
        /**
         * OSX can't handle displaying accelerators for multiple keystrokes.
         * If they are sent across, it will stop processing accelerators for the rest
         * of the menu items. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        filterMultipleKeystroke(keystrokesByCommand? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        sendToBrowserProcess(template? : any, keystrokesByCommand? : any) : any;
    
        /**
         * Get an {Array} of {String} classes for the given element. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        classesForElement(element? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        sortPackagesMenu() : any;
    
    }

    /**
     * Model
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class Model {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static resetNextInstanceId() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        alive: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(params? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        assignId(id? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        destroy() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isAlive() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isDestroyed() : boolean;
    
    }

    /**
     * Extend semver.Range to memoize matched versions for speed 
     */
    export class Range /*extends SemVerModule.SemVer*/ {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor();
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        test(version? : any) : any;
    
    }

    /**
     * Allows messaging the user. This will likely change, dont use
     * quite yet! 
     */
    class NotificationManager {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor();
    
        /**
         * Events
         * This field or method was marked private by atomdoc. Use with caution.
         */
        onDidAddNotification(callback? : any) : EventKit.Disposable;
    
        /**
         * Adding Notifications
         * This field or method was marked private by atomdoc. Use with caution.
         */
        addSuccess(message? : any, options? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        addInfo(message? : any, options? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        addWarning(message? : any, options? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        addError(message? : any, options? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        addFatalError(message? : any, options? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        add(type? : any, message? : any, options? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        addNotification(notification? : Notification) : Notification;
    
        /**
         * Getting Notifications
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getNotifications() : Notification[];
    
        /**
         * Managing Notifications
         * This field or method was marked private by atomdoc. Use with caution.
         */
        clear() : any;
    
    }

    /**
     * This will likely change, do not use. 
     */
    export class Notification {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        type: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        message: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        options: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(type? : any, message? : any, options? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidDismiss(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidDisplay(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getOptions() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getType() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getMessage() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getTimestamp() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getDetail() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isEqual(other? : any) : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        dismiss() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isDismissed() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isDismissable() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        wasDisplayed() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setDisplayed(displayed? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getIcon() : any;
    
    }

    /**
     * OverlayManager
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class OverlayManager {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        presenter: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        container: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(presenter? : any, container? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        render(state? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        shouldUpdateOverlay(decorationId? : any, overlay? : any) : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        measureOverlays() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        measureOverlay(decorationId? : any, itemView? : SpacePen.View) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        renderOverlay(state? : any, decorationId? : any, options? : (item? : any,pixelPosition? : TextBuffer.Point | { row: number; column: number } | [number, number]) => any) : any;
    
    }

    /**
     * Package manager for coordinating the lifecycle of Atom packages.
     */
    class PackageManager {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        devMode: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        resourcePath: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(configDirPath? : any, devMode? : any, safeMode? : any, resourcePath? : any);
    
        /**
         * Invoke the given callback when all packages have been loaded.
         * @param callback? - {Function}
         */
        onDidLoadInitialPackages(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when all packages have been activated.
         * @param callback? - {Function}
         */
        onDidActivateInitialPackages(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when a package is activated.
         * @param callback? - A {Function} to be invoked when a package is activated.
         */
        onDidActivatePackage(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when a package is deactivated.
         * @param callback? - A {Function} to be invoked when a package is deactivated.
         */
        onDidDeactivatePackage(callback? : Function) : Q.Promise<Package>;
    
        /**
         * Invoke the given callback when a package is loaded.
         * @param callback? - A {Function} to be invoked when a package is loaded.
         */
        onDidLoadPackage(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when a package is unloaded.
         * @param callback? - A {Function} to be invoked when a package is unloaded.
         */
        onDidUnloadPackage(callback? : Function) : EventKit.Disposable;
    
        /**
         * Get the path to the apm command.
         * 
         * Return a {String} file path to apm. 
         */
        getApmPath() : any;
    
        /**
         * Get the paths being used to look for packages.
        Returns an {Array} of {String} directory paths.
         */
        getPackageDirPaths() : string[];
    
        /**
         * Resolve the given package name to a path on disk.
         * 
         * Return a {String} folder path or undefined if it could not be resolved. 
         * @param name? - The {String} package name.
         */
        resolvePackagePath(name? : string) : any;
    
        /**
         * Is the package with the given name bundled with Atom?
         * @param name? - The {String} package name.
         */
        isBundledPackage(name? : string) : boolean;
    
        /**
         * Enable the package with the given name.
         */
        enablePackage(name? : string) : Package;
    
        /**
         * Disable the package with the given name.
         */
        disablePackage(name? : string) : Package;
    
        /**
         * Is the package with the given name disabled?
         * @param name? - The {String} package name.
         */
        isPackageDisabled(name? : string) : boolean;
    
        /**
         * Get an {Array} of all the active {Package}s. 
         */
        getActivePackages() : Package[];
    
        /**
         * Get the active {Package} with the given name.
         * @param name? - The {String} package name.
         */
        getActivePackage(name? : string) : Package;
    
        /**
         * Is the {Package} with the given name active?
         * @param name? - The {String} package name.
         */
        isPackageActive(name? : string) : boolean;
    
        /**
         * Get an {Array} of all the loaded {Package}s 
         */
        getLoadedPackages() : Package[];
    
        /**
         * Get packages for a certain package type
         * This field or method was marked private by atomdoc. Use with caution.
         * @param types? - an {Array} of {String}s like ['atom', 'textmate']. 
         */
        getLoadedPackagesForTypes(types? : any[]) : any;
    
        /**
         * Get the loaded {Package} with the given name.
         * @param name? - The {String} package name.
         */
        getLoadedPackage(name? : string) : Package;
    
        /**
         * Is the package with the given name loaded?
         * @param name? - The {String} package name.
         */
        isPackageLoaded(name? : string) : boolean;
    
        /**
         * Get an {Array} of {String}s of all the available package paths. 
         */
        getAvailablePackagePaths() : any;
    
        /**
         * Get an {Array} of {String}s of all the available package names. 
         */
        getAvailablePackageNames() : string;
    
        /**
         * Get an {Array} of {String}s of all the available package metadata. 
         */
        getAvailablePackageMetadata() : any;
    
        /**
         * Private
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getPackageState(name? : string) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setPackageState(name? : string, state? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getPackageDependencies() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        hasAtomEngine(packagePath? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        unobserveDisabledPackages() : Package[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        observeDisabledPackages() : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        loadPackages() : Package[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        loadPackage(nameOrPath? : string) : Package;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        unloadPackages() : Package[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        unloadPackage(name? : string) : Package;
    
        /**
         * Activate all the packages that should be activated. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        activate() : void;
    
        /**
         * another type of package manager can handle other package types.
         * See ThemeManager 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        registerPackageActivator(activator? : any, types? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        activatePackages(packages? : Package[]) : Q.Promise<Package>[];
    
        /**
         * Activate a single package by name 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        activatePackage(name? : string) : Q.Promise<Package>;
    
        /**
         * Deactivate all packages 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        deactivatePackages() : Q.Promise<Package>[];
    
        /**
         * Deactivate the package with the given name 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        deactivatePackage(name? : string) : Q.Promise<Package>;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        handleMetadataError(error? : any, packagePath? : any) : any;
    
    }

    /**
     * Loads and activates a package's main module and resources such as
     * stylesheets, keymaps, grammar, editor properties, and menus. 
     */
    class Package {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static isBundledPackagePath(packagePath? : any) : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static loadMetadata(packagePath? : any, ignoreErrors? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        path: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        metadata: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        keymaps: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        menus: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        stylesheets: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        stylesheetDisposables: EventKit.Disposable[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        grammars: FirstMate.Grammar[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        settings: void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        mainModulePath: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        resolvedMainModulePath: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        mainModule: any /* default */;
    
        /**
         * Construction
         * This field or method was marked private by atomdoc. Use with caution.
         */
        constructor(path? : any, metadata? : any);
    
        /**
         * Invoke the given callback when all packages have been activated.
         * @param callback? - {Function}
         */
        onDidDeactivate(callback? : Function) : EventKit.Disposable;
    
        /**
         * Instance Methods
         * This field or method was marked private by atomdoc. Use with caution.
         */
        enable() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        disable() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isTheme() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        measure(key? : any, fn? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getType() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getStyleSheetPriority() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        load() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        reset() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        activate() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        activateNow() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        activateConfig() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        activateStylesheets() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        activateResources() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        activateServices() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        loadKeymaps() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        loadMenus() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getKeymapPaths() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getMenuPaths() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        loadStylesheets() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getStylesheetsPath() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getStylesheetPaths() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        loadGrammarsSync() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        loadGrammars() : FirstMate.Grammar[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        loadSettings() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        serialize() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        deactivate() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        deactivateConfig() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        deactivateResources() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        reloadStylesheets() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        requireMainModule() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getMainModulePath() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        hasActivationCommands() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        subscribeToActivationCommands() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getActivationCommands() : any;
    
        /**
         * Does the given module path contain native code? 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        isNativeModule(modulePath? : any) : boolean;
    
        /**
         * Get an array of all the native modules that this package depends on.
         * This will recurse through all dependencies. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getNativeModuleDependencyPaths() : any;
    
        /**
         * Get the incompatible native modules that this package depends on.
         * This recurses through all dependencies and requires all modules that
         * contain a `.node` file.
         * 
         * This information is cached in local storage on a per package/version basis
         * to minimize the impact on startup time. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getIncompatibleNativeModules() : any;
    
        /**
         * Is this package compatible with this version of Atom?
         * 
         * Incompatible packages cannot be activated. This will include packages
         * installed to ~/.atom/packages that were built against node 0.11.10 but
         * now need to be upgrade to node 0.11.13.
         */
        isCompatible() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        handleError(message? : any, error? : any) : any;
    
    }

    /**
     * PaneAxis
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class PaneAxis extends Model {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        parent: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        container: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        orientation: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(container? : any, orientation? : any, children? : any, flexScale? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        deserializeParams(params? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        serializeParams() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getFlexScale() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setFlexScale(flexScale? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getParent() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setParent(parent? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getContainer() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setContainer(container? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getOrientation() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getChildren() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getPanes() : Pane[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getItems() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidAddChild(fn? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidRemoveChild(fn? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidReplaceChild(fn? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidDestroy(fn? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidChangeFlexScale(fn? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        observeFlexScale(fn? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        addChild(child? : any, index? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        adjustFlexScale() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        removeChild(child? : any, replacing? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        replaceChild(oldChild? : any, newChild? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        insertChildBefore(currentChild? : any, newChild? : any) : TextBuffer.Range | boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        insertChildAfter(currentChild? : any, newChild? : any) : TextBuffer.Range | boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        reparentLastChild() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        subscribeToChild(child? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        unsubscribeFromChild(child? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        destroyed() : void;
    
    }

    /**
     * Manages the list of panes within a {WorkspaceView} 
     */
    class PaneContainerView extends SpacePen.View {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static content() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        element: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(element? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setModel(model? : Model) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getRoot() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onActivePaneItemChanged(activeItem? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        confirmClose() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getPaneViews() : PaneView[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        indexOfPane(paneView? : Pane) : Pane;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        paneAtIndex(index? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        eachPaneView(callback? : any) : PaneView;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getFocusedPane() : Pane;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getActivePane() : Pane;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getActivePaneView() : PaneView;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getActivePaneItem() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getActiveView() : SpacePen.View;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        paneForUri(uri? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        focusNextPaneView() : PaneView;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        focusPreviousPaneView() : PaneView;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        focusPaneViewAbove() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        focusPaneViewBelow() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        focusPaneViewOnLeft() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        focusPaneViewOnRight() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getPanes() : Pane[];
    
    }

    /**
     * PaneContainer
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class PaneContainer extends Model {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static version: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        root: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(params? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        deserializeParams(params? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        serializeParams(params? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        registerViewProviders() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidChangeRoot(fn? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        observeRoot(fn? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidAddPane(fn? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        observePanes(fn? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidDestroyPane(fn? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidChangeActivePane(fn? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        observeActivePane(fn? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidAddPaneItem(fn? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        observePaneItems(fn? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidChangeActivePaneItem(fn? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        observeActivePaneItem(fn? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onWillDestroyPaneItem(fn? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidDestroyPaneItem(fn? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getRoot() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setRoot(root? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        replaceChild(oldChild? : any, newChild? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getPanes() : Pane[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getPaneItems() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getActivePane() : Pane;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setActivePane(activePane? : Pane) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getActivePaneItem() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        paneForURI(uri? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        paneForItem(item? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        saveAll() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        confirmClose(options? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        activateNextPane() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        activatePreviousPane() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        destroyEmptyPanes() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        willDestroyPaneItem(event? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        didDestroyPaneItem(event? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        didAddPane(event? : any) : Pane;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        didDestroyPane(event? : any) : Pane;
    
        /**
         * Called by Model superclass when destroyed 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        destroyed() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        monitorActivePaneItem() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        monitorPaneItems() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        addedPaneItem(item? : any, pane? : Pane, index? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        removedPaneItem(item? : any) : any;
    
    }

    /**
     * A container which can contains multiple items to be switched between.
     */
    class PaneView extends SpacePen.View {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        element: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        previousActiveItem: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        attached: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(element? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setModel(model? : Model) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        afterAttach() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onPaneDestroyed() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        remove() : any;
    
        getModel() : Model;
    
        /**
         * Use ::destroyItem 
         */
        removeItem(item? : any) : any;
    
        /**
         * Use ::activateItem 
         */
        showItem(item? : any) : any;
    
        /**
         * Use ::activateItemForUri 
         */
        showItemForUri(item? : any) : any;
    
        /**
         * Use ::activateItemAtIndex 
         */
        showItemAtIndex(index? : any) : any;
    
        /**
         * Use ::activateNextItem 
         */
        showNextItem() : any;
    
        /**
         * Use ::activatePreviousItem 
         */
        showPreviousItem() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onActiveStatusChanged(active? : any) : any;
    
        getNextPane() : Pane;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getActivePaneItem() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onActiveItemChanged(item? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onItemAdded(item? : any, index? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onItemRemoved(item? : any, index? : any, destroyed? : void) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onItemMoved(item? : any, newIndex? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onBeforeItemDestroyed(item? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        activeItemTitleChanged() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        activeItemModifiedChanged() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        splitLeft(items? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        splitRight(items? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        splitUp(items? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        splitDown(items? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getContainer() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        focus() : any;
    
    }

    /**
     * A container for presenting content in the center of the workspace.
     * Panes can contain multiple items, one of which is *active* at a given time.
     * The view corresponding to the active item is displayed in the interface. In
     * the default configuration, tabs are also displayed for each item. 
     */
    class Pane extends Model {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(params? : any);
    
        /**
         * Called by the Serializable mixin during serialization. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        serializeParams() : any;
    
        /**
         * Called by the Serializable mixin during deserialization. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        deserializeParams(params? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getParent() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setParent(parent? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getContainer() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setContainer(container? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setFlexScale(flexScale? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getFlexScale() : any;
    
        /**
         * Invoke the given callback when the pane resize
         * 
         * the callback will be invoked when pane's flexScale property changes
         * @param callback? - {Function} to be called when the pane is resized
         */
        onDidChangeFlexScale(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback with all current and future items.
         * @param callback? - {Function} to be called with current and future items.
         */
        observeFlexScale(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when the pane is activated.
         * 
         * The given callback will be invoked whenever {::activate} is called on the
         * pane, even if it is already active at the time.
         * @param callback? - {Function} to be called when the pane is activated.
         */
        onDidActivate(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when the pane is destroyed.
         * @param callback? - {Function} to be called when the pane is destroyed.
         */
        onDidDestroy(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when the value of the {::isActive}
         * property changes.
         * @param callback? - {Function} to be called when the value of the {::isActive} property changes.
         */
        onDidChangeActive(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback with the current and future values of the
         * {::isActive} property.
         * @param callback? - {Function} to be called with the current and future values of the {::isActive} property.
         */
        observeActive(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when an item is added to the pane.
         * @param callback? - {Function} to be called with when items are added.
         */
        onDidAddItem(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when an item is removed from the pane.
         * @param callback? - {Function} to be called with when items are removed.
         */
        onDidRemoveItem(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when an item is moved within the pane.
         * @param callback? - {Function} to be called with when items are moved.
         */
        onDidMoveItem(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback with all current and future items.
         * @param callback? - {Function} to be called with current and future items.
         */
        observeItems(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when the value of {::getActiveItem}
         * changes.
         * @param callback? - {Function} to be called with when the active item changes.
         */
        onDidChangeActiveItem(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback with the current and future values of
         * {::getActiveItem}.
         * @param callback? - {Function} to be called with the current and future active items.
         */
        observeActiveItem(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback before items are destroyed.
         * @param callback? - {Function} to be called before items are destroyed.
         */
        onWillDestroyItem(callback? : Function) : EventKit.Disposable;
    
        /**
         * Called by the view layer to indicate that the pane has gained focus. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        focus() : any;
    
        /**
         * Called by the view layer to indicate that the pane has lost focus. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        blur() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isFocused() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getPanes() : Pane[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        unsubscribeFromItem(item? : any) : any;
    
        /**
         * Get the items in this pane.
        Returns an {Array} of items.
         */
        getItems() : any[];
    
        /**
         * Get the active pane item in this pane.
        Returns a pane item.
         */
        getActiveItem() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setActiveItem(activeItem? : any) : void;
    
        /**
         * Return an {TextEditor} if the pane item is an {TextEditor}, or null otherwise. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getActiveEditor() : any;
    
        /**
         * Return the item at the given index.
         * @param index? - {Number}
        Returns an item or `null` if no item exists at the given index.
         */
        itemAtIndex(index? : number) : any;
    
        /**
         * Makes the next item active. 
         */
        activateNextItem() : void;
    
        /**
         * Makes the previous item active. 
         */
        activatePreviousItem() : void;
    
        /**
         * Move the active tab to the right. 
         */
        moveItemRight() : void;
    
        /**
         * Move the active tab to the left 
         */
        moveItemLeft() : void;
    
        /**
         * Get the index of the active item.
        Returns a {Number}.
         */
        getActiveItemIndex() : number;
    
        /**
         * Activate the item at the given index.
         * @param index? - {Number} 
         */
        activateItemAtIndex(index? : number) : void;
    
        /**
         * Make the given item *active*, causing it to be displayed by
         * the pane's view. 
         */
        activateItem(item? : any) : void;
    
        /**
         * Add the given item to the pane.
         * @param item? - The item to add. It can be a model with an associated view or a view.
         * @param index? - {Number} indicating the index at which to add the item. If omitted, the item is added after the current active item.
        Returns the added item.
         */
        addItem(item? : any, index? : number) : any;
    
        /**
         * Add the given items to the pane.
         * @param items? - An {Array} of items to add. Items can be views or models with associated views. Any objects that are already present in the pane's current items will not be added again.
         * @param index? - {Number} index at which to add the items. If omitted, the item is #   added after the current active item.
        Returns an {Array} of added items.
         */
        addItems(items? : any[], index? : number) : any[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        removeItem(item? : any, destroyed? : void) : any;
    
        /**
         * Move the given item to the given index.
         * @param item? - The item to move.
         */
        moveItem(item? : any, newIndex? : any) : void;
    
        /**
         * Move the given item to the given index on another pane.
         * @param item? - The item to move.
         * @param pane? - {Pane} to which to move the item.
         * @param index? - {Number} indicating the index to which to move the item in the given pane. 
         */
        moveItemToPane(item? : any, pane? : Pane, index? : number) : void;
    
        /**
         * Destroy the active item and activate the next item. 
         */
        destroyActiveItem() : void;
    
        /**
         * Destroy the given item.
         * 
         * If the item is active, the next item will be activated. If the item is the
         * last item, the pane will be destroyed if the `core.destroyEmptyPanes` config
         * setting is `true`.
         * @param item? - Item to destroy 
         */
        destroyItem(item? : any) : void;
    
        /**
         * Destroy all items. 
         */
        destroyItems() : void;
    
        /**
         * Destroy all items except for the active item. 
         */
        destroyInactiveItems() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        promptToSaveItem(item? : any, options? : any) : any;
    
        /**
         * Save the active item. 
         */
        saveActiveItem(nextAction? : any) : void;
    
        /**
         * Prompt the user for a location and save the active item with the
         * path they select.
         * @param nextAction? - {Function} which will be called after the item is successfully saved. 
         */
        saveActiveItemAs(nextAction? : Function) : void;
    
        /**
         * Save the given item.
         * @param item? - The item to save.
         * @param nextAction? - {Function} which will be called after the item is successfully saved. 
         */
        saveItem(item? : any, nextAction? : Function) : void;
    
        /**
         * Prompt the user for a location and save the active item with the
         * path they select.
         * @param item? - The item to save.
         * @param nextAction? - {Function} which will be called after the item is successfully saved. 
         */
        saveItemAs(item? : any, nextAction? : Function) : void;
    
        /**
         * Save all items. 
         */
        saveItems() : void;
    
        /**
         * Return the first item that matches the given URI or undefined if
         * none exists.
         * @param uri? - {String} containing a URI. 
         */
        itemForURI(uri? : string) : any;
    
        /**
         * Activate the first item that matches the given URI.
         */
        activateItemForURI(uri? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        copyActiveItem() : any;
    
        /**
         * Determine whether the pane is active.
         */
        isActive() : boolean;
    
        /**
         * Makes this pane the *active* pane, causing it to gain focus. 
         */
        activate() : void;
    
        /**
         * Close the pane and destroy all its items.
         * 
         * If this is the last pane, all the items will be destroyed but the pane
         * itself will not be destroyed. 
         */
        destroy() : void;
    
        /**
         * Called by model superclass. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        destroyed() : void;
    
        /**
         * Create a new pane to the left of this pane.
         * @param params? - {Object} with the following keys:
        Returns the new {Pane}.
         */
        splitLeft(params? : Object) : Pane;
    
        /**
         * Create a new pane to the right of this pane.
         * @param params? - {Object} with the following keys:
        Returns the new {Pane}.
         */
        splitRight(params? : Object) : Pane;
    
        /**
         * Creates a new pane above the receiver.
         * @param params? - {Object} with the following keys:
        Returns the new {Pane}.
         */
        splitUp(params? : Object) : Pane;
    
        /**
         * Creates a new pane below the receiver.
         * @param params? - {Object} with the following keys:
        Returns the new {Pane}.
         */
        splitDown(params? : Object) : Pane;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        split(orientation? : any, side? : any, params? : any) : any;
    
        /**
         * If the parent is a horizontal axis, returns its first child if it is a pane;
         * otherwise returns this pane. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        findLeftmostSibling() : any;
    
        /**
         * If the parent is a horizontal axis, returns its last child if it is a pane;
         * otherwise returns a new pane created by splitting this pane rightward. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        findOrCreateRightmostSibling() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        close() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        confirmClose() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        handleSaveError(error? : any) : any;
    
    }

    /**
     * PanelContainer
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class PanelContainer {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        location: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(location? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        destroy() : void;
    
        /**
         * Event Subscription
         * This field or method was marked private by atomdoc. Use with caution.
         */
        onDidAddPanel(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidRemovePanel(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidDestroy(callback? : any) : EventKit.Disposable;
    
        /**
         * Panels
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getLocation() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isModal() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getPanels() : Panel[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        addPanel(panel? : Panel) : Panel;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        panelForItem(item? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        panelDestroyed(panel? : Panel) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getPanelIndex(panel? : Panel) : any;
    
    }

    /**
     * A container representing a panel on the edges of the editor window.
     * You should not create a `Panel` directly, instead use {Workspace::addTopPanel}
     * and friends to add panels.
     */
    class Panel {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        item: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        visible: boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        priority: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        className: string;
    
        /**
         * Construction and Destruction
         * This field or method was marked private by atomdoc. Use with caution.
         */
        constructor(item? : any, visible? : boolean, priority? : any, className? : string);
    
        /**
         * Destroy and remove this panel from the UI. 
         */
        destroy() : void;
    
        /**
         * Invoke the given callback when the pane hidden or shown.
         * @param callback? - {Function} to be called when the pane is destroyed.
         */
        onDidChangeVisible(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when the pane is destroyed.
         * @param callback? - {Function} to be called when the pane is destroyed.
         */
        onDidDestroy(callback? : Function) : EventKit.Disposable;
    
        getItem() : any;
    
        getPriority() : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getClassName() : string;
    
        isVisible() : boolean;
    
        /**
         * Hide this panel 
         */
        hide() : any;
    
        /**
         * Show this panel 
         */
        show() : any;
    
    }

    /**
     * Represents a project that's opened in Atom.
     */
    class Project extends Model {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buffers: any /* default */;
    
        /**
         * Construction and Destruction
         * This field or method was marked private by atomdoc. Use with caution.
         */
        constructor(path? : any, paths? : any, buffers? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        destroyed() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        destroyUnretainedBuffers() : void;
    
        /**
         * Serialization
         * This field or method was marked private by atomdoc. Use with caution.
         */
        serializeParams() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        deserializeParams(params? : any) : any;
    
        /**
         * Invoke the given callback when the project paths change.
         * @param callback? - {Function} to be called after the project paths change.
         */
        onDidChangePaths(callback? : Function) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidAddBuffer(callback? : any) : EventKit.Disposable;
    
        /**
         * Get an {Array} of {GitRepository}s associated with the project's
         * directories.
         * 
         * This method will be removed in 2.0 because it does synchronous I/O.
         * Prefer the following, which evaluates to a {Promise} that resolves to an
         * {Array} of {Repository} objects:
         * 
         * ```
         * Promise.all(project.getDirectories().map(
         *     project.repositoryForDirectory.bind(project)))
         * ```
         */
        getRepositories() : any;
    
        /**
         * Get the repository for a given directory asynchronously.
         * @param directory? - {Directory} for which to get a {Repository}.
         */
        repositoryForDirectory(directory? : Pathwatcher.Directory) : Pathwatcher.Directory;
    
        /**
         * Get an {Array} of {String}s containing the paths of the project's
         * directories. 
         */
        getPaths() : any;
    
        /**
         * Set the paths of the project's directories.
         * @param projectPaths? - {Array} of {String} paths. 
         */
        setPaths(projectPaths? : any[]) : void;
    
        /**
         * Add a path to the project's list of root paths
         * @param projectPath? - {String} The path to the directory to add. 
         */
        addPath(projectPath? : string, options? : any) : any;
    
        /**
         * remove a path from the project's list of root paths.
         * @param projectPath? - {String} The path to remove. 
         */
        removePath(projectPath? : string) : any;
    
        /**
         * Get an {Array} of {Directory}s associated with this project. 
         */
        getDirectories() : Pathwatcher.Directory[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        resolvePath(uri? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        relativize(fullPath? : any) : any;
    
        /**
         * Get the path to the project directory that contains the given path,
         * and the relative path from that project directory to the given path.
         * @param fullPath? - {String} An absolute path.
        Returns an {Array} with two elements:

* `projectPath` The {String} path to the project directory that contains the
  given path, or `null` if none is found.
* `relativePath` {String} The relative path from the project directory to
  the given path.
         */
        relativizePath(fullPath? : string) : any[];
    
        /**
         * Determines whether the given path (real or symbolic) is inside the
         * project's directory.
         * 
         * This method does not actually check if the path exists, it just checks their
         * locations relative to each other.
         * @param pathToCheck? - {String} path
        Returns whether the path is inside the project's root directory.
         */
        contains(pathToCheck? : string) : any;
    
        /**
         * Given a path to a file, this constructs and associates a new
         * {TextEditor}, showing the file.
         * This field or method was marked private by atomdoc. Use with caution.
         * @param filePath? - The {String} path of the file to associate with.
         * @param options? - Options that you can pass to the {TextEditor} constructor.
         */
        open(filePath? : string, options? : Q.Promise<TextEditor>) : Q.Promise<TextEditor>;
    
        /**
         * Retrieves all the {TextBuffer}s in the project; that is, the
         * buffers for all open files.
         * This field or method was marked private by atomdoc. Use with caution.
        Returns an {Array} of {TextBuffer}s.
         */
        getBuffers() : TextBuffer.TextBuffer[];
    
        /**
         * Is the buffer for the given path modified? 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        isPathModified(filePath? : any) : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        findBufferForPath(filePath? : any) : any;
    
        /**
         * Only to be used in specs 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        bufferForPathSync(filePath? : any) : any;
    
        /**
         * Given a file path, this retrieves or creates a new {TextBuffer}.
         * 
         * If the `filePath` already has a `buffer`, that value is used instead. Otherwise,
         * `text` is used as the contents of the new buffer.
         * This field or method was marked private by atomdoc. Use with caution.
         * @param filePath? - A {String} representing a path. If `null`, an "Untitled" buffer is created.
        Returns a promise that resolves to the {TextBuffer}.
         */
        bufferForPath(filePath? : string) : TextBuffer.TextBuffer;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        bufferForId(id? : any) : any;
    
        /**
         * Still needed when deserializing a tokenized buffer 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        buildBufferSync(absoluteFilePath? : any) : any;
    
        /**
         * Given a file path, this sets its {TextBuffer}.
         * This field or method was marked private by atomdoc. Use with caution.
         * @param absoluteFilePath? - A {String} representing a path.
        Returns a promise that resolves to the {TextBuffer}.
         */
        buildBuffer(absoluteFilePath? : string) : TextBuffer.TextBuffer;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        addBuffer(buffer? : any, options? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        addBufferAtIndex(buffer? : any, index? : any, options? : any) : any;
    
        /**
         * Removes a {TextBuffer} association from the project.
         * This field or method was marked private by atomdoc. Use with caution.
        Returns the removed {TextBuffer}.
         */
        removeBuffer(buffer? : any) : TextBuffer.TextBuffer;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        removeBufferAtIndex(index? : any, options? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildEditorForBuffer(buffer? : any, editorOptions? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        eachBuffer(args? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        subscribeToBuffer(buffer? : any) : any;
    
    }

    /**
     * Used by the display buffer to map screen rows to buffer rows and vice-versa.
     * This mapping may not be 1:1 due to folds and soft-wraps. This object maintains
     * an array of regions, which contain `bufferRows` and `screenRows` fields.
     */
    class RowMap {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor();
    
        getRegions() : any;
    
        screenRowRangeForBufferRow(targetBufferRow? : number) : TextBuffer.Range;
    
        bufferRowRangeForScreenRow(targetScreenRow? : number) : TextBuffer.Range;
    
        /**
         * If the given buffer row is part of a folded row range, returns that
         * row range. Otherwise returns a range spanning only the given buffer row. 
         */
        bufferRowRangeForBufferRow(targetBufferRow? : number) : TextBuffer.Range;
    
        /**
         * Given a starting buffer row, the number of buffer rows to replace,
         * and an array of regions of shape {bufferRows: n, screenRows: m}, splices
         * the regions at the appropriate location in the map. This method is used by
         * display buffer to keep the map updated when the underlying buffer changes. 
         */
        spliceRegions(startBufferRow? : number, bufferRowCount? : any, regions? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        traverseToBufferRow(targetBufferRow? : number) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        traverseToScreenRow(targetScreenRow? : number) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        mergeAdjacentRectangularRegions(startIndex? : any, endIndex? : any) : any;
    
        inspect() : any;
    
    }

    /**
     * Wraps an {Array} of `String`s. The Array describes a path from the
     * root of the syntax tree to a token including _all_ scope names for the entire
     * path.
     */
    class ScopeDescriptor {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static fromObject(scopes? : Scope[]) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        scopes: Scope[];
    
        /**
         * Create a {ScopeDescriptor} object.
         */
        constructor(scopes? : Scope[]);
    
        getScopesArray() : string[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getScopeChain() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        toString() : any;
    
    }

    /**
     * ScopedProperties
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class ScopedProperties {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static load(scopedPropertiesPath? : any, callback? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        path: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        scopedProperties: ScopedProperties;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(path? : any, scopedProperties? : ScopedProperties);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        activate() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        deactivate() : void;
    
    }

    /**
     * Represents a view that scrolls.
     */
    class ScrollView extends SpacePen.View {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        initialize() : any;
    
    }

    /**
     * ScrollbarComponent
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class ScrollbarComponent {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        orientation: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onScroll: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(orientation? : any, onScroll? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateSync(state? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateVertical() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateHorizontal() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onScrollCallback() : any;
    
    }

    /**
     * ScrollbarCornerComponent
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class ScrollbarCornerComponent {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor();
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateSync(state? : any) : void;
    
    }

    /**
     * Provides a view that renders a list of items with an editor that
     * filters the items. Used by many packages such as the fuzzy-finder,
     * command-palette, symbols-view and autocomplete.
     */
    class SelectListView extends SpacePen.View {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static content() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        maxItems: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        scheduleTimeout: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        inputThrottle: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        cancelling: any /* default */;
    
        /**
         * Initialize the select list view.
         * 
         * This method can be overridden by subclasses but `super` should always
         * be called. 
         */
        initialize() : any;
    
        /**
         * Create a view for the given model item.
         * 
         * This method must be overridden by subclasses.
         * 
         * This is called when the item is about to appended to the list view.
         * @param item? - The model item being rendered. This will always be one of the items previously passed to {::setItems}.
        Returns a String of HTML, DOM element, jQuery object, or View.
         */
        viewForItem(item? : any) : any;
    
        /**
         * Callback function for when an item is selected.
         * 
         * This method must be overridden by subclasses.
         * @param item? - The selected model item. This will always be one of the items previously passed to {::setItems}.
        Returns a DOM element, jQuery object, or {View}.
         */
        confirmed(item? : any) : SpacePen.View;
    
        /**
         * Set the array of items to display in the list.
         * 
         * This should be model items not actual views. {::viewForItem} will be
         * called to render the item when it is being appended to the list view.
         * @param items? - The {Array} of model items to display in the list (default: []). 
         */
        setItems(items? : any[]) : void;
    
        /**
         * Get the model item that is currently selected in the list view.
        Returns a model item.
         */
        getSelectedItem() : any;
    
        /**
         * Get the property name to use when filtering items.
         * 
         * This method may be overridden by classes to allow fuzzy filtering based
         * on a specific property of the item objects.
         * 
         * For example if the objects you pass to {::setItems} are of the type
         * `{"id": 3, "name": "Atom"}` then you would return `"name"` from this method
         * to fuzzy filter by that property when text is entered into this view's
         * editor.
        Returns the property name to fuzzy filter by.
         */
        getFilterKey() : any;
    
        /**
         * Get the filter query to use when fuzzy filtering the visible
         * elements.
         * 
         * By default this method returns the text in the mini editor but it can be
         * overridden by subclasses if needed.
        Returns a {String} to use when fuzzy filtering the elements to display.
         */
        getFilterQuery() : string;
    
        /**
         * Set the maximum numbers of items to display in the list.
         * @param maxItems? - The maximum {Number} of items to display. 
         */
        setMaxItems(maxItems? : number) : void;
    
        /**
         * Populate the list view with the model items previously set by
         * calling {::setItems}.
         * 
         * Subclasses may override this method but should always call `super`. 
         */
        populateList() : any;
    
        /**
         * Set the error message to display.
         * @param message? - The {String} error message (default: ''). 
         */
        setError(message? : string) : void;
    
        /**
         * Set the loading message to display.
         * @param message? - The {String} loading message (default: ''). 
         */
        setLoading(message? : string) : void;
    
        /**
         * Get the message to display when there are no items.
         * 
         * Subclasses may override this method to customize the message.
         * @param itemCount? - The {Number} of items in the array specified to {::setItems}
         * @param filteredItemCount? - The {Number} of items that pass the fuzzy filter test.
        Returns a {String} message (default: 'No matches found').
         */
        getEmptyMessage(itemCount? : number, filteredItemCount? : number) : string;
    
        /**
         * Cancel and close this select list view.
         * 
         * This restores focus to the previously focused element if
         * {::storeFocusedElement} was called prior to this view being attached. 
         */
        cancel() : any;
    
        /**
         * Focus the fuzzy filter editor view. 
         */
        focusFilterEditor() : any;
    
        /**
         * Store the currently focused element. This element will be given
         * back focus when {::cancel} is called. 
         */
        storeFocusedElement() : any;
    
        /**
         * Private
         * This field or method was marked private by atomdoc. Use with caution.
         */
        selectPreviousItemView() : SpacePen.View;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        selectNextItemView() : SpacePen.View;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        selectItemView(view? : SpacePen.View) : SpacePen.View;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        scrollToItemView(view? : SpacePen.View) : SpacePen.View;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        restoreFocus() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        cancelled() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getSelectedItemView() : SpacePen.View;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        confirmSelection() : Selection;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        schedulePopulateList() : any;
    
    }

    /**
     * Represents a selection in the {TextEditor}. 
     */
    class Selection extends Model {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        cursor: Cursor;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        marker: Marker;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        editor: Atom.TextEditor;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        initialScreenRange: TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        wordwise: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(cursor? : Cursor, marker? : Marker, editor? : TextEditor, id? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        destroy() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isLastSelection() : boolean;
    
        /**
         * Calls your `callback` when the selection was moved.
         * @param callback? - {Function}
         */
        onDidChangeRange(callback? : Function) : TextBuffer.Range;
    
        /**
         * Calls your `callback` when the selection was destroyed
         * @param callback? - {Function}
         */
        onDidDestroy(callback? : Function) : EventKit.Disposable;
    
        getScreenRange() : TextBuffer.Range;
    
        /**
         * Modifies the screen range for the selection.
         * @param screenRange? - The new {Range} to use.
         * @param options? - {Object} options matching those found in {::setBufferRange}. 
         */
        setScreenRange(screenRange? : TextBuffer.Range, options? : Object) : TextBuffer.Range;
    
        getBufferRange() : TextBuffer.Range;
    
        /**
         * Modifies the buffer {Range} for the selection.
         * @param options? - {Object} with the keys:
         */
        setBufferRange(bufferRange? : TextBuffer.Range, options? : Object) : TextBuffer.Range;
    
        getBufferRowRange() : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getTailScreenPosition() : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getTailBufferPosition() : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getHeadScreenPosition() : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getHeadBufferPosition() : TextBuffer.Point;
    
        /**
         * Determines if the selection contains anything. 
         */
        isEmpty() : boolean;
    
        /**
         * Determines if the ending position of a marker is greater than the
         * starting position.
         * 
         * This can happen when, for example, you highlight text "up" in a {TextBuffer}. 
         */
        isReversed() : boolean;
    
        isSingleScreenLine() : boolean;
    
        getText() : string;
    
        /**
         * Identifies if a selection intersects with a given buffer range.
         * @param bufferRange? - A {Range} to check against.
         */
        intersectsBufferRange(bufferRange? : TextBuffer.Range) : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        intersectsScreenRowRange(startRow? : number, endRow? : number) : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        intersectsScreenRow(screenRow? : number) : number;
    
        /**
         * Identifies if a selection intersects with another selection.
         * @param otherSelection? - A {Selection} to check against.
        Returns a {Boolean}
         */
        intersectsWith(otherSelection? : Selection, exclusive? : any) : boolean;
    
        /**
         * Clears the selection, moving the marker to the head.
         * @param options? - {Object} with the following keys:
         */
        clear(options? : Object) : any;
    
        /**
         * Selects the text from the current cursor position to a given screen
         * position.
         * @param position? - An instance of {Point}, with a given `row` and `column`. 
         */
        selectToScreenPosition(position? : TextBuffer.Point | { row: number; column: number } | [number, number]) : TextBuffer.Point;
    
        /**
         * Selects the text from the current cursor position to a given buffer
         * position.
         * @param position? - An instance of {Point}, with a given `row` and `column`. 
         */
        selectToBufferPosition(position? : TextBuffer.Point | { row: number; column: number } | [number, number]) : TextBuffer.Point;
    
        /**
         * Selects the text one position right of the cursor.
         * @param columnCount? - {Number} number of columns to select (default: 1) 
         */
        selectRight(columnCount? : number) : any;
    
        /**
         * Selects the text one position left of the cursor.
         * @param columnCount? - {Number} number of columns to select (default: 1) 
         */
        selectLeft(columnCount? : number) : any;
    
        /**
         * Selects all the text one position above the cursor.
         * @param rowCount? - {Number} number of rows to select (default: 1) 
         */
        selectUp(rowCount? : number) : any;
    
        /**
         * Selects all the text one position below the cursor.
         * @param rowCount? - {Number} number of rows to select (default: 1) 
         */
        selectDown(rowCount? : number) : any;
    
        /**
         * Selects all the text from the current cursor position to the top of
         * the buffer. 
         */
        selectToTop() : any;
    
        /**
         * Selects all the text from the current cursor position to the bottom
         * of the buffer. 
         */
        selectToBottom() : any;
    
        /**
         * Selects all the text in the buffer. 
         */
        selectAll() : any;
    
        /**
         * Selects all the text from the current cursor position to the
         * beginning of the line. 
         */
        selectToBeginningOfLine() : any;
    
        /**
         * Selects all the text from the current cursor position to the first
         * character of the line. 
         */
        selectToFirstCharacterOfLine() : any;
    
        /**
         * Selects all the text from the current cursor position to the end of
         * the line. 
         */
        selectToEndOfLine() : any;
    
        /**
         * Selects all the text from the current cursor position to the
         * beginning of the word. 
         */
        selectToBeginningOfWord() : any;
    
        /**
         * Selects all the text from the current cursor position to the end of
         * the word. 
         */
        selectToEndOfWord() : any;
    
        /**
         * Selects all the text from the current cursor position to the
         * beginning of the next word. 
         */
        selectToBeginningOfNextWord() : any;
    
        /**
         * Selects text to the previous word boundary. 
         */
        selectToPreviousWordBoundary() : any;
    
        /**
         * Selects text to the next word boundary. 
         */
        selectToNextWordBoundary() : any;
    
        /**
         * Selects all the text from the current cursor position to the
         * beginning of the next paragraph. 
         */
        selectToBeginningOfNextParagraph() : any;
    
        /**
         * Selects all the text from the current cursor position to the
         * beginning of the previous paragraph. 
         */
        selectToBeginningOfPreviousParagraph() : any;
    
        /**
         * Modifies the selection to encompass the current word.
        Returns a {Range}.
         */
        selectWord() : TextBuffer.Range;
    
        /**
         * Expands the newest selection to include the entire word on which
         * the cursors rests. 
         */
        expandOverWord() : any;
    
        /**
         * Selects an entire line in the buffer.
         * @param row? - The line {Number} to select (default: the row of the cursor). 
         */
        selectLine(row? : number) : any;
    
        /**
         * Expands the newest selection to include the entire line on which
         * the cursor currently rests.
         * 
         * It also includes the newline character. 
         */
        expandOverLine() : any;
    
        /**
         * Replaces text at the current selection.
         * @param text? - A {String} representing the text to add
         * @param options? - {Object} with keys:
         */
        insertText(text? : string, options? : Object) : TextBuffer.Range | boolean;
    
        /**
         * Removes the first character before the selection if the selection
         * is empty otherwise it deletes the selection. 
         */
        backspace() : void;
    
        /**
         * Removes from the start of the selection to the beginning of the
         * current word if the selection is empty otherwise it deletes the selection. 
         */
        deleteToBeginningOfWord() : void;
    
        /**
         * Removes from the beginning of the line which the selection begins on
         * all the way through to the end of the selection. 
         */
        deleteToBeginningOfLine() : void;
    
        /**
         * Removes the selection or the next character after the start of the
         * selection if the selection is empty. 
         */
        delete() : void;
    
        /**
         * If the selection is empty, removes all text from the cursor to the
         * end of the line. If the cursor is already at the end of the line, it
         * removes the following newline. If the selection isn't empty, only deletes
         * the contents of the selection. 
         */
        deleteToEndOfLine() : void;
    
        /**
         * Removes the selection or all characters from the start of the
         * selection to the end of the current word if nothing is selected. 
         */
        deleteToEndOfWord() : void;
    
        /**
         * Removes only the selected text. 
         */
        deleteSelectedText() : void;
    
        /**
         * Removes the line at the beginning of the selection if the selection
         * is empty unless the selection spans multiple lines in which case all lines
         * are removed. 
         */
        deleteLine() : void;
    
        /**
         * Joins the current line with the one below it. Lines will
         * be separated by a single space.
         * 
         * If there selection spans more than one line, all the lines are joined together. 
         */
        joinLines() : any;
    
        /**
         * Removes one level of indent from the currently selected rows. 
         */
        outdentSelectedRows() : number[];
    
        /**
         * Sets the indentation level of all selected rows to values suggested
         * by the relevant grammars. 
         */
        autoIndentSelectedRows() : number[];
    
        /**
         * Wraps the selected lines in comments if they aren't currently part
         * of a comment.
         * 
         * Removes the comment if they are currently wrapped in a comment. 
         */
        toggleLineComments() : any;
    
        /**
         * Cuts the selection until the end of the line. 
         */
        cutToEndOfLine(maintainClipboard? : Clipboard) : any;
    
        /**
         * Copies the selection to the clipboard and then deletes it.
         * @param maintainClipboard? - {Boolean} (default: false) See {::copy}
         * @param fullLine? - {Boolean} (default: false) See {::copy} 
         */
        cut(maintainClipboard? : boolean, fullLine? : boolean) : any;
    
        /**
         * Copies the current selection to the clipboard.
         * @param maintainClipboard? - {Boolean} if `true`, a specific metadata property is created to store each content copied to the clipboard. The clipboard `text` still contains the concatenation of the clipboard with the current selection. (default: false)
         * @param fullLine? - {Boolean} if `true`, the copied text will always be pasted at the beginning of the line containing the cursor, regardless of the cursor's horizontal position. (default: false) 
         */
        copy(maintainClipboard? : boolean, fullLine? : boolean) : Selection;
    
        /**
         * Creates a fold containing the current selection. 
         */
        fold() : Fold;
    
        /**
         * Increase the indentation level of the given text by given number
         * of levels. Leaves the first line unchanged. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        adjustIndent(lines? : any, indentAdjustment? : any) : any;
    
        /**
         * Indent the current line(s).
         * 
         * If the selection is empty, indents the current line if the cursor precedes
         * non-whitespace characters, and otherwise inserts a tab. If the selection is
         * non empty, calls {::indentSelectedRows}.
         * This field or method was marked private by atomdoc. Use with caution.
         */
        indent(autoIndent? : any) : any;
    
        /**
         * If the selection spans multiple rows, indent all of them. 
         */
        indentSelectedRows() : number[];
    
        /**
         * Moves the selection down one row. 
         */
        addSelectionBelow() : any;
    
        /**
         * Moves the selection up one row. 
         */
        addSelectionAbove() : any;
    
        /**
         * Combines the given selection into this selection and then destroys
         * the given selection.
         * @param otherSelection? - A {Selection} to merge with.
         * @param options? - {Object} options matching those found in {::setBufferRange}. 
         */
        merge(otherSelection? : Selection, options? : Object) : any;
    
        /**
         * Compare this selection's buffer range to another selection's buffer
         * range.
         * 
         * See {Range::compare} for more details.
         * @param otherSelection? - A {Selection} to compare against 
         */
        compare(otherSelection? : Selection) : any;
    
        /**
         * Private Utilities
         * This field or method was marked private by atomdoc. Use with caution.
         */
        screenRangeChanged(e? : any) : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        finalize() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        autoscroll() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        clearAutoscroll() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        modifySelection(fn? : any) : Selection;
    
        /**
         * Sets the marker's tail to the same position as the marker's head.
         * 
         * This only works if there isn't already a tail position.
         * This field or method was marked private by atomdoc. Use with caution.
        Returns a {Point} representing the new tail position.
         */
        plantTail() : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getGoalScreenRange() : TextBuffer.Range;
    
    }

    /**
     * StorageFolder
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class StorageFolder {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(containingPath? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        store(name? : string, object? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        load(name? : string) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pathForKey(name? : string) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getPath() : any;
    
    }

    /**
     * A singleton instance of this class available via `atom.styles`,
     * which you can use to globally query and observe the set of active style
     * sheets. The `StyleManager` doesn't add any style elements to the DOM on its
     * own, but is instead subscribed to by individual `<atom-styles>` elements,
     * which clone and attach style elements in different contexts. 
     */
    class StyleManager {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor();
    
        /**
         * Invoke `callback` for all current and future style elements.
         * @param callback? - {Function} that is called with style elements.
         */
        observeStyleElements(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke `callback` when a style element is added.
         * @param callback? - {Function} that is called with style elements.
         */
        onDidAddStyleElement(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke `callback` when a style element is removed.
         * @param callback? - {Function} that is called with style elements.
         */
        onDidRemoveStyleElement(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke `callback` when an existing style element is updated.
         * @param callback? - {Function} that is called with style elements.
         */
        onDidUpdateStyleElement(callback? : Function) : EventKit.Disposable;
    
        /**
         * Get all loaded style elements. 
         */
        getStyleElements() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        addStyleSheet(source? : any, params? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        addStyleElement(styleElement? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        removeStyleElement(styleElement? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getSnapshot() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        restoreSnapshot(styleElementsToRestore? : any) : any;
    
        /**
         * Get the path of the user style sheet in `~/.atom`.
        Returns a {String}.
         */
        getUserStyleSheetPath() : string;
    
    }

    /**
     * Run a node script in a separate process.
     */
    class Task {
        /**
         * A helper method to easily launch and run a task once.
         * @param taskPath? - The {String} path to the CoffeeScript/JavaScript file which exports a single {Function} to execute.
        Returns the created {Task}.
         */
        static once(taskPath? : string, args? : any) : Task;
    
        /**
         * Called upon task completion.
         * 
         * It receives the same arguments that were passed to the task.
         * 
         * If subclassed, this is intended to be overridden. However if {::start}
         * receives a completion callback, this is overridden. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        callback: any /* default */;
    
        /**
         * Creates a task. You should probably use {.once}
         * @param taskPath? - The {String} path to the CoffeeScript/JavaScript file that exports a single {Function} to execute. 
         */
        constructor(taskPath? : string);
    
        /**
         * Routes messages from the child to the appropriate event. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        handleEvents() : any;
    
        /**
         * Starts the task.
         * 
         * Throws an error if this task has already been terminated or if sending a
         * message to the child process fails.
         * @param callback? - A {Function} to call when the task completes. 
         */
        start(args? : any, callback? : Function) : any;
    
        /**
         * Send message to the task.
         * 
         * Throws an error if this task has already been terminated or if sending a
         * message to the child process fails.
         * @param message? - The message to send to the task. 
         */
        send(message? : any) : any;
    
        /**
         * Call a function when an event is emitted by the child process
         * @param eventName? - The {String} name of the event to handle.
         * @param callback? - The {Function} to call when the event is emitted.
        Returns a {Disposable} that can be used to stop listening for the event.
         */
        on(eventName? : string, callback? : Function) : EventKit.Disposable;
    
        /**
         * Forcefully stop the running task.
         * 
         * No more events are emitted once this method is called. 
         */
        terminate() : any;
    
    }

    /**
     * TextEditorComponent
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class TextEditorComponent {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        editor: Atom.TextEditor;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        hostElement: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        rootElement: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        stylesElement: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        useShadowDOM: boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        scrollSensitivity: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        cursorBlinkPeriod: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        cursorBlinkResumeDelay: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        lineOverdrawMargin: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pendingScrollTop: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pendingScrollLeft: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateRequested: void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updatesPaused: void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateRequestedWhilePaused: void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        heightAndWidthMeasurementRequested: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        cursorMoved: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        selectionChanged: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        inputEnabled: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        measureScrollbarsWhenShown: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        measureLineHeightAndDefaultCharWidthWhenShown: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        remeasureCharacterWidthsWhenShown: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        stylingChangeAnimationFrameRequested: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        gutterComponent: GutterComponent;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        mounted: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(editor? : TextEditor, hostElement? : any, rootElement? : any, stylesElement? : any, useShadowDOM? : boolean, lineOverdrawMargin? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        destroy() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateSync() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        readAfterUpdateSync() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        mountGutterComponent() : GutterComponent;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        becameVisible() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        requestUpdate() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        canUpdate() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        requestAnimationFrame(fn? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getTopmostDOMNode() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        observeEditor() : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        listenForDOMEvents() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        listenForIMEEvents() : any;
    
        /**
         * Listen for selection changes and store the currently selected text
         * in the selection clipboard. This is only applicable on Linux. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        trackSelectionClipboard() : Clipboard;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        observeConfig() : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onGrammarChanged() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        focused() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        blurred() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onTextInput(event? : any) : string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onVerticalScroll(scrollTop? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onHorizontalScroll(scrollLeft? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onMouseWheel(event? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onScrollViewScroll() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onMouseDown(event? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onGutterMouseDown(event? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onGutterClick(event? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onGutterMetaClick(event? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onGutterShiftClick(event? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onStylesheetsChanged(styleElement? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onAllThemesLoaded() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        handleStylingChange() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onSelectionAdded(selection? : Selection) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onSelectionChanged(selection? : Selection) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onCursorAdded(cursor? : Cursor) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onCursorMoved() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        handleDragUntilMouseUp(event? : any, dragHandler? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isVisible() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pollDOM() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        checkForVisibilityChange() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        requestHeightAndWidthMeasurement() : any;
    
        /**
         * Measure explicitly-styled height and width and relay them to the model. If
         * these values aren't explicitly styled, we assume the editor is unconstrained
         * and use the scrollHeight / scrollWidth as its height and width in
         * calculations. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        measureDimensions() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        measureWindowSize() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        sampleFontStyling() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        sampleBackgroundColors(suppressUpdate? : any) : Color[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        measureLineHeightAndDefaultCharWidth() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        remeasureCharacterWidths() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        measureScrollbars() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        containsScrollbarSelector(stylesheet? : any) : ScopedPropertyStore.Selector;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        refreshScrollbars() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        consolidateSelections(e? : any) : Selection[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        lineNodeForScreenRow(screenRow? : number) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        lineNumberNodeForScreenRow(screenRow? : number) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        screenRowForNode(node? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getFontSize() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setFontSize(fontSize? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getFontFamily() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setFontFamily(fontFamily? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setLineHeight(lineHeight? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setShowIndentGuide(showIndentGuide? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setScrollSensitivity(scrollSensitivity? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        screenPositionForMouseEvent(event? : any) : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pixelPositionForMouseEvent(event? : any) : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getModel() : Model;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isInputEnabled() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setInputEnabled(inputEnabled? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateParentViewFocusedClassIfNeeded() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateParentViewMiniClass() : void;
    
    }

    /**
     * TextEditorPresenter
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class TextEditorPresenter {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        toggleCursorBlinkHandle: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        startBlinkingCursorsAfterDelay: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        stoppedScrollingTimeoutId: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        mouseWheelScreenRow: number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        scopedCharacterWidthsChangeCount: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        overlayDimensions: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(params? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        destroy() : void;
    
        /**
         * Calls your `callback` when some changes in the model occurred and the current state has been updated. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        onDidUpdateState(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        emitDidUpdateState() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        transferMeasurementsToModel() : Model;
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        isBatching() : boolean;
    
        /**
         * Executes `fn` if `isBatching()` is false, otherwise sets `@[flagName]` to `true` for later processing. In either cases, it calls `emitDidUpdateState`.
         * This field or method was marked private by atomdoc. Use with caution.
         * @param flagName? - {String} name of a property of this presenter
         * @param fn? - {Function} to call when not batching. 
         */
        batch(flagName? : string, fn? : Function) : any;
    
        getState() : any | Object;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        observeModel() : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        observeConfig() : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        didChangeGrammar() : FirstMate.Grammar;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildState() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateState() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateFocusedState() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateHeightState() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateVerticalScrollState() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateHorizontalScrollState() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateScrollbarsState() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateHiddenInputState() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateContentState() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateLinesState() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateLineState(row? : number, line? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildLineState(row? : number, line? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateCursorsState() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateCursorState(cursor? : Cursor, destroyOnly? : void) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateOverlaysState() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateGutterState() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateLineNumbersState() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateStartRow() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateEndRow() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateScrollWidth() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateScrollHeight() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateContentDimensions() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateClientHeight() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateClientWidth() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateScrollTop() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constrainScrollTop(scrollTop? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateScrollLeft() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constrainScrollLeft(scrollLeft? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateScrollbarDimensions() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        lineDecorationClassesForRow(row? : number) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        lineNumberDecorationClassesForRow(row? : number) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getCursorBlinkPeriod() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getCursorBlinkResumeDelay() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setFocused(focused? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setScrollTop(scrollTop? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        didStartScrolling() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        didStopScrolling() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setScrollLeft(scrollLeft? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setHorizontalScrollbarHeight(horizontalScrollbarHeight? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setVerticalScrollbarWidth(verticalScrollbarWidth? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setAutoHeight(autoHeight? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setExplicitHeight(explicitHeight? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateHeight() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setContentFrameWidth(contentFrameWidth? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setBoundingClientRect(boundingClientRect? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        clientRectsEqual(clientRectA? : any, clientRectB? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setWindowSize(width? : any, height? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setBackgroundColor(backgroundColor? : Color) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setGutterBackgroundColor(gutterBackgroundColor? : Color) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setLineHeight(lineHeight? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setMouseWheelScreenRow(mouseWheelScreenRow? : number) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setBaseCharacterWidth(baseCharacterWidth? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getScopedCharacterWidth(scopeNames? : string, char? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getScopedCharacterWidths(scopeNames? : string) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        batchCharacterMeasurement(fn? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setScopedCharacterWidth(scopeNames? : string, character? : any, width? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        characterWidthsChanged() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        clearScopedCharacterWidths() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        hasPixelPositionRequirements() : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pixelPositionForScreenPosition(screenPosition? : TextBuffer.Point | { row: number; column: number } | [number, number], clip? : any) : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        hasPixelRectRequirements() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        hasOverlayPositionRequirements() : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pixelRectForScreenRange(screenRange? : TextBuffer.Range) : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        observeDecoration(decoration? : Decoration) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        decorationMarkerDidChange(decoration? : Decoration, change? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        didDestroyDecoration(decoration? : Decoration) : Decoration;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        highlightDidFlash(decoration? : Decoration) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        didAddDecoration(decoration? : Decoration) : Decoration;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateDecorations() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        removeFromLineDecorationCaches(decoration? : Decoration, range? : TextBuffer.Range) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        addToLineDecorationCaches(decoration? : Decoration, range? : TextBuffer.Range) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateHighlightState(decoration? : Decoration) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildHighlightRegions(screenRange? : TextBuffer.Range) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setOverlayDimensions(decorationId? : any, itemWidth? : any, itemHeight? : any, contentMargin? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        observeCursor(cursor? : Cursor) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        didAddCursor(cursor? : Cursor) : Cursor;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        startBlinkingCursors() : Cursor[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        stopBlinkingCursors(visible? : boolean) : Cursor[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        toggleCursorBlink() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pauseCursorBlinking() : any;
    
    }

    /**
     * Represents the entire visual pane in Atom.
     */
    class TextEditorView extends SpacePen.View {
        /**
         * The constructor for setting up an `TextEditorView` instance.
         * This field or method was marked private by atomdoc. Use with caution.
         * @param modelOrParams? - Either an {TextEditor}, or an object with one property, `mini`.  If `mini` is `true`, a "miniature" `TextEditor` is constructed.  Typically, this is ideal for scenarios where you need an Atom editor,  but without all the chrome, like scrollbars, gutter, _e.t.c._.
         */
        constructor(modelOrParams? : TextEditor, props? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setModel(model? : Model) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        find() : any;
    
        /**
         * Get the underlying editor model for this view.
         */
        getModel() : Model;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getEditor() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        afterAttach(onDom? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        beforeRemove() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        remove(selector? : any, keepData? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        scrollTop(scrollTop? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        scrollLeft(scrollLeft? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        scrollToBottom() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        scrollToScreenPosition(screenPosition? : TextBuffer.Point | { row: number; column: number } | [number, number], options? : any) : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        scrollToBufferPosition(bufferPosition? : TextBuffer.Point | { row: number; column: number } | [number, number], options? : any) : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        scrollToCursorPosition() : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pixelPositionForBufferPosition(bufferPosition? : TextBuffer.Point | { row: number; column: number } | [number, number]) : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pixelPositionForScreenPosition(screenPosition? : TextBuffer.Point | { row: number; column: number } | [number, number]) : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        appendToLinesView(view? : SpacePen.View) : SpacePen.View;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        splitLeft() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        splitRight() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        splitUp() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        splitDown() : any;
    
        /**
         * Get this {TextEditorView}'s {PaneView}.
         */
        getPaneView() : PaneView;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getPane() : Pane;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        show() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        hide() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pageDown() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pageUp() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getFirstVisibleScreenRow() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getLastVisibleScreenRow() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getFontFamily() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setFontFamily(fontFamily? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getFontSize() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setFontSize(fontSize? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setLineHeight(lineHeight? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setWidthInChars(widthInChars? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setShowIndentGuide(showIndentGuide? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setSoftWrap(softWrapped? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setShowInvisibles(showInvisibles? : boolean) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getText() : string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setText(text? : string) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        insertText(text? : string) : TextBuffer.Range | boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isInputEnabled() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setInputEnabled(inputEnabled? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        requestDisplayUpdate() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateDisplay() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        resetDisplay() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        redraw() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setPlaceholderText(placeholderText? : string) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        lineElementForScreenRow(screenRow? : number) : number;
    
    }

    /**
     * This class represents all essential editing state for a single
     * {TextBuffer}, including cursor and selection positions, folds, and soft wraps.
     * If you're manipulating the state of an editor, use this class. If you're
     * interested in the visual appearance of editors, use {TextEditorView} instead.
     */
    class TextEditor extends Model {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        softTabs: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        displayBuffer: DisplayBuffer;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        mini: boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        placeholderText: string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        gutterVisible: boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        deserializing: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        callDisplayBufferCreatedHook: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        registerEditor: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buffer: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        languageMode: LanguageMode;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        cursors: Cursor[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        selections: Selection[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        suppressSelectionMerging: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateBatchDepth: void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        selectionFlashDuration: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(softTabs? : any, initialLine? : any, initialColumn? : number, tabLength? : any, softWrapped? : any, displayBuffer? : DisplayBuffer, buffer? : any, registerEditor? : any, suppressCursorCreation? : any, mini? : boolean, placeholderText? : string, gutterVisible? : boolean);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        serializeParams() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        deserializeParams(params? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        subscribeToBuffer() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        subscribeToDisplayBuffer() : DisplayBuffer;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        subscribeToScopedConfigSettings() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        destroyed() : void;
    
        /**
         * Calls your `callback` when the buffer's title has changed.
         * @param callback? - {Function}
         */
        onDidChangeTitle(callback? : Function) : EventKit.Disposable;
    
        /**
         * Calls your `callback` when the buffer's path, and therefore title, has changed.
         * @param callback? - {Function}
         */
        onDidChangePath(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback synchronously when the content of the
         * buffer changes.
         * 
         * Because observers are invoked synchronously, it's important not to perform
         * any expensive operations via this method. Consider {::onDidStopChanging} to
         * delay expensive operations until after changes stop occurring.
         * @param callback? - {Function}
         */
        onDidChange(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke `callback` when the buffer's contents change. It is
         * emit asynchronously 300ms after the last buffer change. This is a good place
         * to handle changes to the buffer without compromising typing performance.
         * @param callback? - {Function}
         */
        onDidStopChanging(callback? : Function) : EventKit.Disposable;
    
        /**
         * Calls your `callback` when a {Cursor} is moved. If there are
         * multiple cursors, your callback will be called for each cursor.
         * @param callback? - {Function}
         */
        onDidChangeCursorPosition(callback? : Function) : TextBuffer.Point;
    
        /**
         * Calls your `callback` when a selection's screen range changes.
         * @param callback? - {Function}
         */
        onDidChangeSelectionRange(callback? : Function) : TextBuffer.Range;
    
        /**
         * Calls your `callback` when soft wrap was enabled or disabled.
         * @param callback? - {Function}
         */
        onDidChangeSoftWrapped(callback? : Function) : EventKit.Disposable;
    
        /**
         * Calls your `callback` when the buffer's encoding has changed.
         * @param callback? - {Function}
         */
        onDidChangeEncoding(callback? : Function) : EventKit.Disposable;
    
        /**
         * Calls your `callback` when the grammar that interprets and
         * colorizes the text has been changed. Immediately calls your callback with
         * the current grammar.
         * @param callback? - {Function}
         */
        observeGrammar(callback? : Function) : EventKit.Disposable;
    
        /**
         * Calls your `callback` when the grammar that interprets and
         * colorizes the text has been changed.
         * @param callback? - {Function}
         */
        onDidChangeGrammar(callback? : Function) : EventKit.Disposable;
    
        /**
         * Calls your `callback` when the result of {::isModified} changes.
         * @param callback? - {Function}
         */
        onDidChangeModified(callback? : Function) : EventKit.Disposable;
    
        /**
         * Calls your `callback` when the buffer's underlying file changes on
         * disk at a moment when the result of {::isModified} is true.
         * @param callback? - {Function}
         */
        onDidConflict(callback? : Function) : EventKit.Disposable;
    
        /**
         * Calls your `callback` before text has been inserted.
         * @param callback? - {Function}
         */
        onWillInsertText(callback? : Function) : EventKit.Disposable;
    
        /**
         * Calls your `callback` adter text has been inserted.
         * @param callback? - {Function}
         */
        onDidInsertText(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback after the buffer is saved to disk.
         * @param callback? - {Function} to be called after the buffer is saved.
         */
        onDidSave(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when the editor is destroyed.
         * @param callback? - {Function} to be called when the editor is destroyed.
         */
        onDidDestroy(callback? : Function) : EventKit.Disposable;
    
        /**
         * Calls your `callback` when a {Cursor} is added to the editor.
         * Immediately calls your callback for each existing cursor.
         * @param callback? - {Function}
         */
        observeCursors(callback? : Function) : EventKit.Disposable;
    
        /**
         * Calls your `callback` when a {Cursor} is added to the editor.
         * @param callback? - {Function}
         */
        onDidAddCursor(callback? : Function) : EventKit.Disposable;
    
        /**
         * Calls your `callback` when a {Cursor} is removed from the editor.
         * @param callback? - {Function}
         */
        onDidRemoveCursor(callback? : Function) : EventKit.Disposable;
    
        /**
         * Calls your `callback` when a {Selection} is added to the editor.
         * Immediately calls your callback for each existing selection.
         * @param callback? - {Function}
         */
        observeSelections(callback? : Function) : EventKit.Disposable;
    
        /**
         * Calls your `callback` when a {Selection} is added to the editor.
         * @param callback? - {Function}
         */
        onDidAddSelection(callback? : Function) : EventKit.Disposable;
    
        /**
         * Calls your `callback` when a {Selection} is removed from the editor.
         * @param callback? - {Function}
         */
        onDidRemoveSelection(callback? : Function) : EventKit.Disposable;
    
        /**
         * Calls your `callback` with each {Decoration} added to the editor.
         * Calls your `callback` immediately for any existing decorations.
         * @param callback? - {Function}
         */
        observeDecorations(callback? : Function) : EventKit.Disposable;
    
        /**
         * Calls your `callback` when a {Decoration} is added to the editor.
         * @param callback? - {Function}
         */
        onDidAddDecoration(callback? : Function) : EventKit.Disposable;
    
        /**
         * Calls your `callback` when a {Decoration} is removed from the editor.
         * @param callback? - {Function}
         */
        onDidRemoveDecoration(callback? : Function) : EventKit.Disposable;
    
        /**
         * Calls your `callback` when the placeholder text is changed.
         * @param callback? - {Function}
         */
        onDidChangePlaceholderText(callback? : Function) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidChangeCharacterWidths(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidChangeScrollTop(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidChangeScrollLeft(callback? : any) : EventKit.Disposable;
    
        /**
         * TODO Remove once the tabs package no longer uses .on subscriptions 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        onDidChangeIcon(callback? : any) : EventKit.Disposable;
    
        /**
         * Retrieves the current {TextBuffer}. 
         */
        getBuffer() : TextBuffer.TextBuffer;
    
        /**
         * Retrieves the current buffer's URI. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getURI() : string;
    
        /**
         * Create an {TextEditor} with its initial state based on this object 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        copy() : TextEditor;
    
        /**
         * Controls visibility based on the given {Boolean}. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        setVisible(visible? : boolean) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setMini(mini? : boolean) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isMini() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidChangeMini(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setGutterVisible(gutterVisible? : boolean) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isGutterVisible() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidChangeGutterVisible(callback? : any) : EventKit.Disposable;
    
        /**
         * Set the number of characters that can be displayed horizontally in the
         * editor.
         * This field or method was marked private by atomdoc. Use with caution.
         * @param editorWidthInChars? - A {Number} representing the width of the {TextEditorView} in characters. 
         */
        setEditorWidthInChars(editorWidthInChars? : number) : void;
    
        /**
         * Get the editor's title for display in other parts of the
         * UI such as the tabs.
         * 
         * If the editor's buffer is saved, its title is the file name. If it is
         * unsaved, its title is "untitled".
        Returns a {String}.
         */
        getTitle() : string;
    
        /**
         * Get the editor's long title for display in other parts of the UI
         * such as the window title.
         * 
         * If the editor's buffer is saved, its long title is formatted as
         * "<filename> - <directory>". If it is unsaved, its title is "untitled"
        Returns a {String}.
         */
        getLongTitle() : string;
    
        getPath() : string;
    
        getEncoding() : string;
    
        /**
         * Set the character set encoding to use in this editor's text
         * buffer.
         * @param encoding? - The {String} character set encoding name such as 'utf8' 
         */
        setEncoding(encoding? : string) : void;
    
        isModified() : boolean;
    
        isEmpty() : boolean;
    
        /**
         * Copies the current file path to the native clipboard. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        copyPathToClipboard() : Clipboard;
    
        /**
         * Saves the editor's text buffer.
         * 
         * See {TextBuffer::save} for more details. 
         */
        save() : void;
    
        /**
         * Saves the editor's text buffer as the given path.
         * 
         * See {TextBuffer::saveAs} for more details.
         * @param filePath? - A {String} path. 
         */
        saveAs(filePath? : string) : void;
    
        /**
         * Determine whether the user should be prompted to save before closing
         * this editor. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        shouldPromptToSave(windowCloseRequested? : any) : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        checkoutHeadRevision() : any;
    
        getText() : string;
    
        /**
         * Get the text in the given {Range} in buffer coordinates.
         * @param range? - A {Range} or range-compatible {Array}.
         */
        getTextInBufferRange(range? : TextBuffer.Range) : TextBuffer.Range;
    
        getLineCount() : number;
    
        getScreenLineCount() : number;
    
        getLastBufferRow() : number;
    
        getLastScreenRow() : number;
    
        lineTextForBufferRow(bufferRow? : number) : string;
    
        lineTextForScreenRow(screenRow? : number) : string;
    
        /**
         * Gets the screen line for the given screen row.
         * This field or method was marked private by atomdoc. Use with caution.
         * @param screenRow? - A {Number} indicating the screen row.
         */
        tokenizedLineForScreenRow(screenRow? : number) : TokenizedLine;
    
        /**
         * {Delegates to: DisplayBuffer.tokenizedLinesForScreenRows} 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        tokenizedLinesForScreenRows(start? : any, end? : any) : TokenizedLine[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        bufferRowForScreenRow(row? : number) : number;
    
        /**
         * {Delegates to: DisplayBuffer.bufferRowsForScreenRows} 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        bufferRowsForScreenRows(startRow? : number, endRow? : number) : number[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        screenRowForBufferRow(row? : number) : number;
    
        /**
         * {Delegates to: DisplayBuffer.getMaxLineLength} 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getMaxScreenLineLength() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getLongestScreenRow() : number;
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
         * @param row? - A row {Number}.
         * @param options? - An options hash with an `includeNewline` key.
        undefined
         */
        bufferRangeForBufferRow(row? : number, options? : (includeNewline? : any) => any) : TextBuffer.Range;
    
        /**
         * Get the text in the given {Range}.
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getTextInRange(range? : TextBuffer.Range) : TextBuffer.Range;
    
        /**
         * {Delegates to: TextBuffer.isRowBlank} 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        isBufferRowBlank(bufferRow? : number) : boolean;
    
        /**
         * {Delegates to: TextBuffer.nextNonBlankRow} 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        nextNonBlankBufferRow(bufferRow? : number) : number;
    
        /**
         * {Delegates to: TextBuffer.getEndPosition} 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getEofBufferPosition() : TextBuffer.Point;
    
        /**
         * Get the {Range} of the paragraph surrounding the most recently added
         * cursor.
         */
        getCurrentParagraphBufferRange() : TextBuffer.Range;
    
        /**
         * Replaces the entire contents of the buffer with the given {String}. 
         */
        setText(text? : string) : void;
    
        /**
         * Set the text in the given {Range} in buffer coordinates.
         * @param range? - A {Range} or range-compatible {Array}.
         * @param text? - A {String}
         * @param options? - {Object}
         */
        setTextInBufferRange(range? : TextBuffer.Range, text? : string, options? : Object) : TextBuffer.Range;
    
        /**
         * For each selection, replace the selected text with the given text.
         * @param text? - A {String} representing the text to insert.
         * @param options? - See {Selection::insertText}.
         */
        insertText(text? : string, options? : any) : TextBuffer.Range | boolean;
    
        /**
         * For each selection, replace the selected text with a newline. 
         */
        insertNewline() : TextBuffer.Range | boolean;
    
        /**
         * For each selection, if the selection is empty, delete the character
         * following the cursor. Otherwise delete the selected text. 
         */
        delete() : void;
    
        /**
         * For each selection, if the selection is empty, delete the character
         * preceding the cursor. Otherwise delete the selected text. 
         */
        backspace() : void;
    
        /**
         * Mutate the text of all the selections in a single transaction.
         * 
         * All the changes made inside the given {Function} can be reverted with a
         * single call to {::undo}.
         * @param fn? - A {Function} that will be called once for each {Selection}. The first    argument will be a {Selection} and the second argument will be the    {Number} index of that selection. 
         */
        mutateSelectedText(fn? : Function) : string;
    
        /**
         * Move lines intersection the most recent selection up by one row in screen
         * coordinates. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        moveLineUp() : void;
    
        /**
         * Move lines intersecting the most recent selection down by one row in screen
         * coordinates. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        moveLineDown() : void;
    
        /**
         * Duplicate the most recent cursor's current line. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        duplicateLines() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        replaceSelectedText(options? : any, fn? : any) : string;
    
        /**
         * Split multi-line selections into one selection per line.
         * 
         * Operates on all selections. This method breaks apart all multi-line
         * selections to create multiple single-line selections that cumulatively cover
         * the same original area. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        splitSelectionsIntoLines() : any;
    
        /**
         * For each selection, transpose the selected text.
         * 
         * If the selection is empty, the characters preceding and following the cursor
         * are swapped. Otherwise, the selected characters are reversed. 
         */
        transpose() : any;
    
        /**
         * Convert the selected text to upper case.
         * 
         * For each selection, if the selection is empty, converts the containing word
         * to upper case. Otherwise convert the selected text to upper case. 
         */
        upperCase() : any;
    
        /**
         * Convert the selected text to lower case.
         * 
         * For each selection, if the selection is empty, converts the containing word
         * to upper case. Otherwise convert the selected text to upper case. 
         */
        lowerCase() : any;
    
        /**
         * Toggle line comments for rows intersecting selections.
         * 
         * If the current grammar doesn't support comments, does nothing. 
         */
        toggleLineCommentsInSelection() : Selection;
    
        /**
         * Convert multiple lines to a single line.
         * 
         * Operates on all selections. If the selection is empty, joins the current
         * line with the next line. Otherwise it joins all lines that intersect the
         * selection.
         * 
         * Joining a line means that multiple lines are converted to a single line with
         * the contents of each of the original non-empty lines separated by a space. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        joinLines() : any;
    
        /**
         * For each cursor, insert a newline at beginning the following line. 
         */
        insertNewlineBelow() : TextBuffer.Range | boolean;
    
        /**
         * For each cursor, insert a newline at the end of the preceding line. 
         */
        insertNewlineAbove() : TextBuffer.Range | boolean;
    
        /**
         * For each selection, if the selection is empty, delete all characters
         * of the containing word that precede the cursor. Otherwise delete the
         * selected text. 
         */
        deleteToBeginningOfWord() : void;
    
        /**
         * For each selection, if the selection is empty, delete all characters
         * of the containing line that precede the cursor. Otherwise delete the
         * selected text. 
         */
        deleteToBeginningOfLine() : void;
    
        /**
         * For each selection, if the selection is not empty, deletes the
         * selection; otherwise, deletes all characters of the containing line
         * following the cursor. If the cursor is already at the end of the line,
         * deletes the following newline. 
         */
        deleteToEndOfLine() : void;
    
        /**
         * For each selection, if the selection is empty, delete all characters
         * of the containing word following the cursor. Otherwise delete the selected
         * text. 
         */
        deleteToEndOfWord() : void;
    
        /**
         * Delete all lines intersecting selections. 
         */
        deleteLine() : void;
    
        /**
         * Undo the last change. 
         */
        undo() : void;
    
        /**
         * Redo the last change. 
         */
        redo() : void;
    
        /**
         * Batch multiple operations as a single undo/redo step.
         * 
         * Any group of operations that are logically grouped from the perspective of
         * undoing and redoing should be performed in a transaction. If you want to
         * abort the transaction, call {::abortTransaction} to terminate the function's
         * execution and revert any changes performed up to the abortion.
         * @param groupingInterval? - The {Number} of milliseconds for which this transaction should be considered 'groupable' after it begins. If a transaction with a positive `groupingInterval` is committed while the previous transaction is still 'groupable', the two transactions are merged with respect to undo and redo.
         * @param fn? - A {Function} to call inside the transaction. 
         */
        transact(groupingInterval? : number, fn? : Function) : any;
    
        /**
         * Start an open-ended transaction. 
         */
        beginTransaction(groupingInterval? : any) : TextBuffer.Transaction;
    
        /**
         * Commit an open-ended transaction started with {::beginTransaction}. 
         */
        commitTransaction() : TextBuffer.Transaction;
    
        /**
         * Abort an open transaction, undoing any operations performed so far
         * within the transaction. 
         */
        abortTransaction() : TextBuffer.Transaction;
    
        /**
         * Create a pointer to the current state of the buffer for use
         * with {::revertToCheckpoint} and {::groupChangesSinceCheckpoint}.
         */
        createCheckpoint() : TextBuffer.Checkpoint;
    
        /**
         * Revert the buffer to the state it was in when the given
         * checkpoint was created.
         * 
         * The redo stack will be empty following this operation, so changes since the
         * checkpoint will be lost. If the given checkpoint is no longer present in the
         * undo history, no changes will be made to the buffer and this method will
         * return `false`.
         */
        revertToCheckpoint(checkpoint? : TextBuffer.Checkpoint) : TextBuffer.Checkpoint;
    
        /**
         * Group all changes since the given checkpoint into a single
         * transaction for purposes of undo/redo.
         * 
         * If the given checkpoint is no longer present in the undo history, no
         * grouping will be performed and this method will return `false`.
         */
        groupChangesSinceCheckpoint(checkpoint? : TextBuffer.Checkpoint) : TextBuffer.Checkpoint;
    
        /**
         * Convert a position in buffer-coordinates to screen-coordinates.
         * 
         * The position is clipped via {::clipBufferPosition} prior to the conversion.
         * The position is also clipped via {::clipScreenPosition} following the
         * conversion, which only makes a difference when `options` are supplied.
         * @param bufferPosition? - A {Point} or {Array} of [row, column].
         * @param options? - An options hash for {::clipScreenPosition}.
         */
        screenPositionForBufferPosition(bufferPosition? : TextBuffer.Point | { row: number; column: number } | [number, number], options? : any) : TextBuffer.Point;
    
        /**
         * Convert a position in screen-coordinates to buffer-coordinates.
         * 
         * The position is clipped via {::clipScreenPosition} prior to the conversion.
         * @param options? - An options hash for {::clipScreenPosition}.
         */
        bufferPositionForScreenPosition(screenPosition? : TextBuffer.Point | { row: number; column: number } | [number, number], options? : any) : TextBuffer.Point;
    
        /**
         * Convert a range in buffer-coordinates to screen-coordinates.
         * @param bufferRange? - {Range} in buffer coordinates to translate into screen coordinates.
         */
        screenRangeForBufferRange(bufferRange? : TextBuffer.Range) : TextBuffer.Range;
    
        /**
         * Convert a range in screen-coordinates to buffer-coordinates.
         * @param screenRange? - {Range} in screen coordinates to translate into buffer coordinates.
         */
        bufferRangeForScreenRange(screenRange? : TextBuffer.Range) : TextBuffer.Range;
    
        /**
         * Clip the given {Point} to a valid position in the buffer.
         * 
         * If the given {Point} describes a position that is actually reachable by the
         * cursor based on the current contents of the buffer, it is returned
         * unchanged. If the {Point} does not describe a valid position, the closest
         * valid position is returned instead.
         * @param bufferPosition? - The {Point} representing the position to clip.
         */
        clipBufferPosition(bufferPosition? : TextBuffer.Point | { row: number; column: number } | [number, number]) : TextBuffer.Point;
    
        /**
         * Clip the start and end of the given range to valid positions in the
         * buffer. See {::clipBufferPosition} for more information.
         * @param range? - The {Range} to clip.
         */
        clipBufferRange(range? : TextBuffer.Range) : TextBuffer.Range;
    
        /**
         * Clip the given {Point} to a valid position on screen.
         * 
         * If the given {Point} describes a position that is actually reachable by the
         * cursor based on the current contents of the screen, it is returned
         * unchanged. If the {Point} does not describe a valid position, the closest
         * valid position is returned instead.
         * @param screenPosition? - The {Point} representing the position to clip.
         * @param options? - {Object}
         */
        clipScreenPosition(screenPosition? : TextBuffer.Point | { row: number; column: number } | [number, number], options? : Object) : TextBuffer.Point;
    
        /**
         * Clip the start and end of the given range to valid positions on screen.
         * See {::clipScreenPosition} for more information.
         * @param range? - The {Range} to clip.
         * @param options? - See {::clipScreenPosition} `options`. Returns a {Range}. 
         */
        clipScreenRange(range? : TextBuffer.Range, options? : TextBuffer.Range) : TextBuffer.Range;
    
        /**
         * Adds a decoration that tracks a {Marker}. When the marker moves,
         * is invalidated, or is destroyed, the decoration will be updated to reflect
         * the marker's state.
         * 
         * There are three types of supported decorations:
         * 
         * * __line__: Adds your CSS `class` to the line nodes within the range
         *     marked by the marker
         * * __gutter__: Adds your CSS `class` to the line number nodes within the
         *     range marked by the marker
         * * __highlight__: Adds a new highlight div to the editor surrounding the
         *     range marked by the marker. When the user selects text, the selection is
         *     visualized with a highlight decoration internally. The structure of this
         *     highlight will be
         *   ```html
         *     <div class="highlight <your-class>">
         *       <!-- Will be one region for each row in the range. Spans 2 lines? There will be 2 regions. -->
         *       <div class="region"></div>
         *     </div>
         *   ```
         * @param marker? - A {Marker} you want this decoration to follow.
         * @param decorationParams? - An {Object} representing the decoration e.g. `{type: 'line-number', class: 'linter-error'}`
         */
        decorateMarker(marker? : Marker, decorationParams? : Object) : Marker;
    
        /**
         * Get all the decorations within a screen row range.
         * @param startScreenRow? - the {Number} beginning screen row
         * @param endScreenRow? - the {Number} end screen row (inclusive)
         */
        decorationsForScreenRowRange(startScreenRow? : number, endScreenRow? : number) : TextBuffer.Range;
    
        /**
         * Get all decorations.
         * @param propertyFilter? - An {Object} containing key value pairs that the returned decorations' properties must match.
         */
        getDecorations(propertyFilter? : Object) : Decoration[];
    
        /**
         * Get all decorations of type 'line'.
         * @param propertyFilter? - An {Object} containing key value pairs that the returned decorations' properties must match.
         */
        getLineDecorations(propertyFilter? : Object) : Decoration[];
    
        /**
         * Get all decorations of type 'line-number'.
         * @param propertyFilter? - An {Object} containing key value pairs that the returned decorations' properties must match.
         */
        getLineNumberDecorations(propertyFilter? : Object) : Decoration[];
    
        /**
         * Get all decorations of type 'highlight'.
         * @param propertyFilter? - An {Object} containing key value pairs that the returned decorations' properties must match.
         */
        getHighlightDecorations(propertyFilter? : Object) : Decoration[];
    
        /**
         * Get all decorations of type 'overlay'.
         * @param propertyFilter? - An {Object} containing key value pairs that the returned decorations' properties must match.
         */
        getOverlayDecorations(propertyFilter? : Object) : Decoration[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        decorationForId(id? : any) : any;
    
        /**
         * Create a marker with the given range in buffer coordinates. This
         * marker will maintain its logical location as the buffer is changed, so if
         * you mark a particular word, the marker will remain over that word even if
         * the word's location in the buffer changes.
         */
        markBufferRange(args? : any) : TextBuffer.Range;
    
        /**
         * Create a marker with the given range in screen coordinates. This
         * marker will maintain its logical location as the buffer is changed, so if
         * you mark a particular word, the marker will remain over that word even if
         * the word's location in the buffer changes.
         */
        markScreenRange(args? : any) : TextBuffer.Range;
    
        /**
         * Mark the given position in buffer coordinates.
         */
        markBufferPosition(args? : any) : TextBuffer.Point;
    
        /**
         * Mark the given position in screen coordinates.
         */
        markScreenPosition(args? : any) : TextBuffer.Point;
    
        /**
         * Find all {Marker}s that match the given properties.
         * 
         * This method finds markers based on the given properties. Markers can be
         * associated with custom properties that will be compared with basic equality.
         * In addition, there are several special properties that will be compared
         * with the range of the markers rather than their properties.
         * @param properties? - An {Object} containing properties that each returned marker must satisfy. Markers can be associated with custom properties, which are compared with basic equality. In addition, several reserved properties can be used to filter markers based on their current range:
         */
        findMarkers(properties? : Object) : Marker[];
    
        /**
         * Get the {Marker} for the given marker id.
         * @param id? - {Number} id of the marker 
         */
        getMarker(id? : number) : Marker;
    
        /**
         * Get all {Marker}s. Consider using {::findMarkers} 
         */
        getMarkers() : Marker[];
    
        /**
         * Get the number of markers in this editor's buffer.
        Returns a {Number}.
         */
        getMarkerCount() : number;
    
        /**
         * {Delegates to: DisplayBuffer.destroyMarker} 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        destroyMarker(args? : any) : void;
    
        /**
         * Get the position of the most recently added cursor in buffer
         * coordinates.
         */
        getCursorBufferPosition() : TextBuffer.Point;
    
        /**
         * Get the position of all the cursor positions in buffer coordinates.
         */
        getCursorBufferPositions() : TextBuffer.Point[];
    
        /**
         * Move the cursor to the given position in buffer coordinates.
         * 
         * If there are multiple cursors, they will be consolidated to a single cursor.
         * @param position? - A {Point} or {Array} of `[row, column]`
         * @param options? - An {Object} combining options for {::clipScreenPosition} with:
         */
        setCursorBufferPosition(position? : TextBuffer.Point | { row: number; column: number } | [number, number], options? : Object) : TextBuffer.Point;
    
        /**
         * Get the position of the most recently added cursor in screen
         * coordinates.
         */
        getCursorScreenPosition() : TextBuffer.Point;
    
        /**
         * Get the position of all the cursor positions in screen coordinates.
         */
        getCursorScreenPositions() : TextBuffer.Point[];
    
        /**
         * Move the cursor to the given position in screen coordinates.
         * 
         * If there are multiple cursors, they will be consolidated to a single cursor.
         * @param position? - A {Point} or {Array} of `[row, column]`
         * @param options? - An {Object} combining options for {::clipScreenPosition} with:
         */
        setCursorScreenPosition(position? : TextBuffer.Point | { row: number; column: number } | [number, number], options? : Object) : TextBuffer.Point;
    
        /**
         * Add a cursor at the given position in buffer coordinates.
         * @param bufferPosition? - A {Point} or {Array} of `[row, column]`
         */
        addCursorAtBufferPosition(bufferPosition? : TextBuffer.Point | { row: number; column: number } | [number, number], options? : any) : TextBuffer.Point;
    
        /**
         * Add a cursor at the position in screen coordinates.
         * @param screenPosition? - A {Point} or {Array} of `[row, column]`
         */
        addCursorAtScreenPosition(screenPosition? : TextBuffer.Point | { row: number; column: number } | [number, number], options? : any) : TextBuffer.Point;
    
        hasMultipleCursors() : Cursor[];
    
        /**
         * Move every cursor up one row in screen coordinates.
         * @param lineCount? - {Number} number of lines to move 
         */
        moveUp(lineCount? : number) : void;
    
        /**
         * Move every cursor down one row in screen coordinates.
         * @param lineCount? - {Number} number of lines to move 
         */
        moveDown(lineCount? : number) : void;
    
        /**
         * Move every cursor left one column.
         * @param columnCount? - {Number} number of columns to move (default: 1) 
         */
        moveLeft(columnCount? : number) : void;
    
        /**
         * Move every cursor right one column.
         * @param columnCount? - {Number} number of columns to move (default: 1) 
         */
        moveRight(columnCount? : number) : void;
    
        /**
         * Move every cursor to the beginning of its line in buffer coordinates. 
         */
        moveToBeginningOfLine() : void;
    
        /**
         * Move every cursor to the beginning of its line in screen coordinates. 
         */
        moveToBeginningOfScreenLine() : void;
    
        /**
         * Move every cursor to the first non-whitespace character of its line. 
         */
        moveToFirstCharacterOfLine() : void;
    
        /**
         * Move every cursor to the end of its line in buffer coordinates. 
         */
        moveToEndOfLine() : void;
    
        /**
         * Move every cursor to the end of its line in screen coordinates. 
         */
        moveToEndOfScreenLine() : void;
    
        /**
         * Move every cursor to the beginning of its surrounding word. 
         */
        moveToBeginningOfWord() : void;
    
        /**
         * Move every cursor to the end of its surrounding word. 
         */
        moveToEndOfWord() : void;
    
        /**
         * Move every cursor to the top of the buffer.
         * 
         * If there are multiple cursors, they will be merged into a single cursor. 
         */
        moveToTop() : void;
    
        /**
         * Move every cursor to the bottom of the buffer.
         * 
         * If there are multiple cursors, they will be merged into a single cursor. 
         */
        moveToBottom() : void;
    
        /**
         * Move every cursor to the beginning of the next word. 
         */
        moveToBeginningOfNextWord() : void;
    
        /**
         * Move every cursor to the previous word boundary. 
         */
        moveToPreviousWordBoundary() : void;
    
        /**
         * Move every cursor to the next word boundary. 
         */
        moveToNextWordBoundary() : void;
    
        /**
         * Move every cursor to the beginning of the next paragraph. 
         */
        moveToBeginningOfNextParagraph() : void;
    
        /**
         * Move every cursor to the beginning of the previous paragraph. 
         */
        moveToBeginningOfPreviousParagraph() : void;
    
        getLastCursor() : Cursor;
    
        getWordUnderCursor(options? : any) : Cursor;
    
        /**
         * Get an Array of all {Cursor}s. 
         */
        getCursors() : Cursor[];
    
        /**
         * Get all {Cursors}s, ordered by their position in the buffer
         * instead of the order in which they were added.
         */
        getCursorsOrderedByBufferPosition() : TextBuffer.Point;
    
        /**
         * Add a cursor based on the given {Marker}. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        addCursor(marker? : Cursor) : Cursor;
    
        /**
         * Remove the given cursor from this editor. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        removeCursor(cursor? : Cursor) : Cursor;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        moveCursors(fn? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        cursorMoved(event? : any) : any;
    
        /**
         * Merge cursors that have the same screen position 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        mergeCursors() : Cursor[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        preserveCursorPositionOnBufferReload() : TextBuffer.Point;
    
        /**
         * Get the selected text of the most recently added selection.
         */
        getSelectedText() : string;
    
        /**
         * Get the {Range} of the most recently added selection in buffer
         * coordinates.
         */
        getSelectedBufferRange() : TextBuffer.Range;
    
        /**
         * Get the {Range}s of all selections in buffer coordinates.
         * 
         * The ranges are sorted by when the selections were added. Most recent at the end.
         */
        getSelectedBufferRanges() : TextBuffer.Range[];
    
        /**
         * Set the selected range in buffer coordinates. If there are multiple
         * selections, they are reduced to a single selection with the given range.
         * @param bufferRange? - A {Range} or range-compatible {Array}.
         * @param options? - An options {Object}:
         */
        setSelectedBufferRange(bufferRange? : TextBuffer.Range, options? : Object) : TextBuffer.Range;
    
        /**
         * Set the selected ranges in buffer coordinates. If there are multiple
         * selections, they are replaced by new selections with the given ranges.
         * @param bufferRanges? - An {Array} of {Range}s or range-compatible {Array}s.
         * @param options? - An options {Object}:
         */
        setSelectedBufferRanges(bufferRanges? : any[], options? : Object) : TextBuffer.Range[];
    
        /**
         * Get the {Range} of the most recently added selection in screen
         * coordinates.
         */
        getSelectedScreenRange() : TextBuffer.Range;
    
        /**
         * Get the {Range}s of all selections in screen coordinates.
         * 
         * The ranges are sorted by when the selections were added. Most recent at the end.
         */
        getSelectedScreenRanges() : TextBuffer.Range[];
    
        /**
         * Set the selected range in screen coordinates. If there are multiple
         * selections, they are reduced to a single selection with the given range.
         * @param screenRange? - A {Range} or range-compatible {Array}.
         * @param options? - An options {Object}:
         */
        setSelectedScreenRange(screenRange? : TextBuffer.Range, options? : Object) : TextBuffer.Range;
    
        /**
         * Set the selected ranges in screen coordinates. If there are multiple
         * selections, they are replaced by new selections with the given ranges.
         * @param screenRanges? - An {Array} of {Range}s or range-compatible {Array}s.
         * @param options? - An options {Object}:
         */
        setSelectedScreenRanges(screenRanges? : any[], options? : Object) : TextBuffer.Range[];
    
        /**
         * Add a selection for the given range in buffer coordinates.
         * @param bufferRange? - A {Range}
         * @param options? - An options {Object}:
         */
        addSelectionForBufferRange(bufferRange? : TextBuffer.Range, options? : Object) : TextBuffer.Range;
    
        /**
         * Add a selection for the given range in screen coordinates.
         * @param screenRange? - A {Range}
         * @param options? - An options {Object}:
         */
        addSelectionForScreenRange(screenRange? : TextBuffer.Range, options? : Object) : TextBuffer.Range;
    
        /**
         * Select from the current cursor position to the given position in
         * buffer coordinates.
         * 
         * This method may merge selections that end up intesecting.
         * @param position? - An instance of {Point}, with a given `row` and `column`. 
         */
        selectToBufferPosition(position? : TextBuffer.Point | { row: number; column: number } | [number, number]) : TextBuffer.Point;
    
        /**
         * Select from the current cursor position to the given position in
         * screen coordinates.
         * 
         * This method may merge selections that end up intesecting.
         * @param position? - An instance of {Point}, with a given `row` and `column`. 
         */
        selectToScreenPosition(position? : TextBuffer.Point | { row: number; column: number } | [number, number]) : TextBuffer.Point;
    
        /**
         * Move the cursor of each selection one character upward while
         * preserving the selection's tail position.
         * 
         * This method may merge selections that end up intesecting. 
         * @param rowCount? - {Number} number of rows to select (default: 1)
         */
        selectUp(rowCount? : number) : any;
    
        /**
         * Move the cursor of each selection one character downward while
         * preserving the selection's tail position.
         * 
         * This method may merge selections that end up intesecting. 
         * @param rowCount? - {Number} number of rows to select (default: 1)
         */
        selectDown(rowCount? : number) : any;
    
        /**
         * Move the cursor of each selection one character leftward while
         * preserving the selection's tail position.
         * 
         * This method may merge selections that end up intesecting. 
         * @param columnCount? - {Number} number of columns to select (default: 1)
         */
        selectLeft(columnCount? : number) : any;
    
        /**
         * Move the cursor of each selection one character rightward while
         * preserving the selection's tail position.
         * 
         * This method may merge selections that end up intesecting. 
         * @param columnCount? - {Number} number of columns to select (default: 1)
         */
        selectRight(columnCount? : number) : any;
    
        /**
         * Select from the top of the buffer to the end of the last selection
         * in the buffer.
         * 
         * This method merges multiple selections into a single selection. 
         */
        selectToTop() : any;
    
        /**
         * Selects from the top of the first selection in the buffer to the end
         * of the buffer.
         * 
         * This method merges multiple selections into a single selection. 
         */
        selectToBottom() : any;
    
        /**
         * Select all text in the buffer.
         * 
         * This method merges multiple selections into a single selection. 
         */
        selectAll() : any;
    
        /**
         * Move the cursor of each selection to the beginning of its line
         * while preserving the selection's tail position.
         * 
         * This method may merge selections that end up intesecting. 
         */
        selectToBeginningOfLine() : any;
    
        /**
         * Move the cursor of each selection to the first non-whitespace
         * character of its line while preserving the selection's tail position. If the
         * cursor is already on the first character of the line, move it to the
         * beginning of the line.
         * 
         * This method may merge selections that end up intersecting. 
         */
        selectToFirstCharacterOfLine() : any;
    
        /**
         * Move the cursor of each selection to the end of its line while
         * preserving the selection's tail position.
         * 
         * This method may merge selections that end up intersecting. 
         */
        selectToEndOfLine() : any;
    
        /**
         * Expand selections to the beginning of their containing word.
         * 
         * Operates on all selections. Moves the cursor to the beginning of the
         * containing word while preserving the selection's tail position. 
         */
        selectToBeginningOfWord() : any;
    
        /**
         * Expand selections to the end of their containing word.
         * 
         * Operates on all selections. Moves the cursor to the end of the containing
         * word while preserving the selection's tail position. 
         */
        selectToEndOfWord() : any;
    
        /**
         * For each cursor, select the containing line.
         * 
         * This method merges selections on successive lines. 
         */
        selectLinesContainingCursors() : Cursor[];
    
        /**
         * Select the word surrounding each cursor. 
         */
        selectWordsContainingCursors() : Cursor[];
    
        /**
         * For each selection, move its cursor to the preceding word boundary
         * while maintaining the selection's tail position.
         * 
         * This method may merge selections that end up intersecting. 
         */
        selectToPreviousWordBoundary() : any;
    
        /**
         * For each selection, move its cursor to the next word boundary while
         * maintaining the selection's tail position.
         * 
         * This method may merge selections that end up intersecting. 
         */
        selectToNextWordBoundary() : any;
    
        /**
         * Expand selections to the beginning of the next word.
         * 
         * Operates on all selections. Moves the cursor to the beginning of the next
         * word while preserving the selection's tail position. 
         */
        selectToBeginningOfNextWord() : any;
    
        /**
         * Expand selections to the beginning of the next paragraph.
         * 
         * Operates on all selections. Moves the cursor to the beginning of the next
         * paragraph while preserving the selection's tail position. 
         */
        selectToBeginningOfNextParagraph() : any;
    
        /**
         * Expand selections to the beginning of the next paragraph.
         * 
         * Operates on all selections. Moves the cursor to the beginning of the next
         * paragraph while preserving the selection's tail position. 
         */
        selectToBeginningOfPreviousParagraph() : any;
    
        /**
         * Select the range of the given marker if it is valid.
         * @param marker? - A {Marker}
         */
        selectMarker(marker? : Marker) : Marker;
    
        /**
         * Get the most recently added {Selection}.
         */
        getLastSelection() : Selection;
    
        /**
         * Get current {Selection}s.
         */
        getSelections() : Selection[];
    
        /**
         * Get all {Selection}s, ordered by their position in the buffer
         * instead of the order in which they were added.
         */
        getSelectionsOrderedByBufferPosition() : TextBuffer.Point;
    
        /**
         * Determine if a given range in buffer coordinates intersects a
         * selection.
         * @param bufferRange? - A {Range} or range-compatible {Array}.
         */
        selectionIntersectsBufferRange(bufferRange? : TextBuffer.Range) : TextBuffer.Range;
    
        /**
         * Add a similarly-shaped selection to the next eligible line below
         * each selection.
         * 
         * Operates on all selections. If the selection is empty, adds an empty
         * selection to the next following non-empty line as close to the current
         * selection's column as possible. If the selection is non-empty, adds a
         * selection to the next line that is long enough for a non-empty selection
         * starting at the same column as the current selection to be added to it. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        addSelectionBelow() : any;
    
        /**
         * Add a similarly-shaped selection to the next eligible line above
         * each selection.
         * 
         * Operates on all selections. If the selection is empty, adds an empty
         * selection to the next preceding non-empty line as close to the current
         * selection's column as possible. If the selection is non-empty, adds a
         * selection to the next line that is long enough for a non-empty selection
         * starting at the same column as the current selection to be added to it. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        addSelectionAbove() : any;
    
        /**
         * Calls the given function with each selection, then merges selections 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        expandSelectionsForward(fn? : any) : any;
    
        /**
         * Calls the given function with each selection, then merges selections in the
         * reversed orientation 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        expandSelectionsBackward(fn? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        finalizeSelections() : Selection[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        selectionsForScreenRows(startRow? : number, endRow? : number) : number[];
    
        /**
         * Merges intersecting selections. If passed a function, it executes
         * the function with merging suppressed, then merges intersecting selections
         * afterward. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        mergeIntersectingSelections(args? : any) : Selection[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        mergeSelectionsOnSameRows(args? : any) : number[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        mergeSelections(args? : any) : Selection[];
    
        /**
         * Add a {Selection} based on the given {Marker}.
         * This field or method was marked private by atomdoc. Use with caution.
         * @param marker? - The {Marker} to highlight
         * @param options? - An {Object} that pertains to the {Selection} constructor.
         */
        addSelection(marker? : Selection, options? : Object) : Selection;
    
        /**
         * Remove the given selection. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        removeSelection(selection? : Selection) : Selection;
    
        /**
         * Reduce one or more selections to a single empty selection based on the most
         * recently added cursor. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        clearSelections(options? : any) : Selection[];
    
        /**
         * Reduce multiple selections to the most recently added selection. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        consolidateSelections() : Selection[];
    
        /**
         * Called by the selection 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        selectionRangeChanged(event? : any) : TextBuffer.Range;
    
        /**
         * Scan regular expression matches in the entire buffer, calling the
         * given iterator function on each match.
         * 
         * `::scan` functions as the replace method as well via the `replace`
         * 
         * If you're programmatically modifying the results, you may want to try
         * {::backwardsScanInBufferRange} to avoid tripping over your own changes.
         * @param regex? - A {RegExp} to search for.
         * @param iterator? - A {Function} that's called on each match
         */
        scan(regex? : RegExp, iterator? : Function) : any;
    
        /**
         * Scan regular expression matches in a given range, calling the given
         * iterator function on each match.
         * @param regex? - A {RegExp} to search for.
         * @param range? - A {Range} in which to search.
         * @param iterator? - A {Function} that's called on each match with an {Object} containing the following keys:
         */
        scanInBufferRange(regex? : RegExp, range? : TextBuffer.Range, iterator? : Function) : TextBuffer.Range;
    
        /**
         * Scan regular expression matches in a given range in reverse order,
         * calling the given iterator function on each match.
         * @param regex? - A {RegExp} to search for.
         * @param range? - A {Range} in which to search.
         * @param iterator? - A {Function} that's called on each match with an {Object} containing the following keys:
         */
        backwardsScanInBufferRange(regex? : RegExp, range? : TextBuffer.Range, iterator? : Function) : TextBuffer.Range;
    
        getSoftTabs() : boolean;
    
        /**
         * Enable or disable soft tabs for this editor.
         * @param softTabs? - A {Boolean} 
         */
        setSoftTabs(softTabs? : boolean) : void;
    
        /**
         * Toggle soft tabs for this editor 
         */
        toggleSoftTabs() : any;
    
        /**
         * Get the on-screen length of tab characters.
        Returns a {Number}.
         */
        getTabLength() : number;
    
        /**
         * Set the on-screen length of tab characters. Setting this to a
         * {Number} This will override the `editor.tabLength` setting.
         * @param tabLength? - {Number} length of a single tab. Setting to `null` will fallback to using the `editor.tabLength` config setting 
         */
        setTabLength(tabLength? : number) : void;
    
        /**
         * Determine if the buffer uses hard or soft tabs.
         */
        usesSoftTabs() : boolean;
    
        /**
         * Get the text representing a single level of indent.
         * 
         * If soft tabs are enabled, the text is composed of N spaces, where N is the
         * tab length. Otherwise the text is a tab character (`\t`).
         */
        getTabText() : string;
    
        /**
         * If soft tabs are enabled, convert all hard tabs to soft tabs in the given
         * {Range}. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        normalizeTabsInBufferRange(bufferRange? : TextBuffer.Range) : TextBuffer.Range;
    
        /**
         * Determine whether lines in this editor are soft-wrapped.
         */
        isSoftWrapped(softWrapped? : any) : boolean;
    
        /**
         * Enable or disable soft wrapping for this editor.
         * @param softWrapped? - A {Boolean}
         */
        setSoftWrapped(softWrapped? : boolean) : void;
    
        /**
         * Toggle soft wrapping for this editor
        Returns a {Boolean}.
         */
        toggleSoftWrapped() : boolean;
    
        /**
         * Gets the column at which column will soft wrap 
         */
        getSoftWrapColumn() : number;
    
        /**
         * Get the indentation level of the given a buffer row.
         */
        indentationForBufferRow(bufferRow? : number) : number;
    
        /**
         * Set the indentation level for the given buffer row.
         * 
         * Inserts or removes hard tabs or spaces based on the soft tabs and tab length
         * settings of this editor in order to bring it to the given indentation level.
         * Note that if soft tabs are enabled and the tab length is 2, a row with 4
         * leading spaces would have an indentation level of 2.
         * @param bufferRow? - A {Number} indicating the buffer row.
         * @param newLevel? - A {Number} indicating the new indentation level.
         * @param options? - An {Object} with the following keys:
         * @param preserveLeadingWhitespace? - `true` to preserve any whitespace already at  the beginning of the line (default: false). 
         */
        setIndentationForBufferRow(bufferRow? : number, newLevel? : number, options? : { preserveLeadingWhitespace? : any }) : void;
    
        /**
         * Indent rows intersecting selections by one level. 
         */
        indentSelectedRows() : number[];
    
        /**
         * Outdent rows intersecting selections by one level. 
         */
        outdentSelectedRows() : number[];
    
        /**
         * Get the indentation level of the given line of text.
        Returns how deeply the given line is indented based on the soft tabs and
tab length settings of this editor. Note that if soft tabs are enabled and
the tab length is 2, a row with 4 leading spaces would have an indentation
level of 2.

* `line` A {String} representing a line of text.
        Returns a {Number}.
         */
        indentLevelForLine(line? : any) : string | number;
    
        /**
         * Indent rows intersecting selections based on the grammar's suggested
         * indent level. 
         */
        autoIndentSelectedRows() : number[];
    
        /**
         * Indent all lines intersecting selections. See {Selection::indent} for more
         * information. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        indent(options? : any) : any;
    
        /**
         * Constructs the string used for tabs. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        buildIndentString(number? : any, column? : number) : any;
    
        /**
         * Get the current {Grammar} of this editor. 
         */
        getGrammar() : FirstMate.Grammar;
    
        /**
         * Set the current {Grammar} of this editor.
         * 
         * Assigning a grammar will cause the editor to re-tokenize based on the new
         * grammar.
         * @param grammar? - {Grammar} 
         */
        setGrammar(grammar? : FirstMate.Grammar) : void;
    
        /**
         * Reload the grammar based on the file name. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        reloadGrammar() : FirstMate.Grammar;
    
        getRootScopeDescriptor() : ScopeDescriptor;
    
        /**
         * Get the syntactic scopeDescriptor for the given position in buffer
         * coordinates. Useful with {Config::get}.
         * 
         * For example, if called with a position inside the parameter list of an
         * anonymous CoffeeScript function, the method returns the following array:
         * `["source.coffee", "meta.inline.function.coffee", "variable.parameter.function.coffee"]`
         * @param bufferPosition? - A {Point} or {Array} of [row, column].
         */
        scopeDescriptorForBufferPosition(bufferPosition? : TextBuffer.Point | { row: number; column: number } | [number, number]) : TextBuffer.Point;
    
        /**
         * Get the range in buffer coordinates of all tokens surrounding the
         * cursor that match the given scope selector.
         * 
         * For example, if you wanted to find the string surrounding the cursor, you
         * could call `editor.bufferRangeForScopeAtCursor(".string.quoted")`.
         * @param scopeSelector? - {String} selector. e.g. `'.source.ruby'`
         */
        bufferRangeForScopeAtCursor(scopeSelector? : string) : TextBuffer.Range;
    
        /**
         * Determine if the given row is entirely a comment 
         */
        isBufferRowCommented(bufferRow? : number) : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        logCursorScope() : Scope;
    
        /**
         * {Delegates to: DisplayBuffer.tokenForBufferPosition} 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        tokenForBufferPosition(bufferPosition? : TextBuffer.Point | { row: number; column: number } | [number, number]) : TextBuffer.Point;
    
        /**
         * For each selection, copy the selected text. 
         */
        copySelectedText() : string;
    
        /**
         * For each selection, cut the selected text. 
         */
        cutSelectedText() : string;
    
        /**
         * For each selection, replace the selected text with the contents of
         * the clipboard.
         * 
         * If the clipboard contains the same number of selections as the current
         * editor, each selection will be replaced with the content of the
         * corresponding clipboard selection text.
         * @param options? - See {Selection::insertText}. 
         */
        pasteText(options? : any) : string;
    
        /**
         * For each selection, if the selection is empty, cut all characters
         * of the containing line following the cursor. Otherwise cut the selected
         * text. 
         */
        cutToEndOfLine() : any;
    
        /**
         * Fold the most recent cursor's row based on its indentation level.
         * 
         * The fold will extend from the nearest preceding line with a lower
         * indentation level up to the nearest following row with a lower indentation
         * level. 
         */
        foldCurrentRow() : number;
    
        /**
         * Unfold the most recent cursor's row by one level. 
         */
        unfoldCurrentRow() : number;
    
        /**
         * Fold the given row in buffer coordinates based on its indentation
         * level.
         * 
         * If the given row is foldable, the fold will begin there. Otherwise, it will
         * begin at the first foldable row preceding the given row.
         * @param bufferRow? - A {Number}. 
         */
        foldBufferRow(bufferRow? : number) : number;
    
        /**
         * Unfold all folds containing the given row in buffer coordinates.
         * @param bufferRow? - A {Number} 
         */
        unfoldBufferRow(bufferRow? : number) : number;
    
        /**
         * For each selection, fold the rows it intersects. 
         */
        foldSelectedLines() : any;
    
        /**
         * Fold all foldable lines. 
         */
        foldAll() : any;
    
        /**
         * Unfold all existing folds. 
         */
        unfoldAll() : any;
    
        /**
         * Fold all foldable lines at the given indent level.
         * @param level? - A {Number}. 
         */
        foldAllAtIndentLevel(level? : number) : any;
    
        /**
         * Determine whether the given row in buffer coordinates is foldable.
         * 
         * A *foldable* row is a row that *starts* a row range that can be folded.
         * @param bufferRow? - A {Number}
         */
        isFoldableAtBufferRow(bufferRow? : number) : boolean;
    
        /**
         * Determine whether the given row in screen coordinates is foldable.
         * 
         * A *foldable* row is a row that *starts* a row range that can be folded.
         */
        isFoldableAtScreenRow(screenRow? : number) : boolean;
    
        /**
         * Fold the given buffer row if it isn't currently folded, and unfold
         * it otherwise. 
         */
        toggleFoldAtBufferRow(bufferRow? : number) : number;
    
        /**
         * Determine whether the most recently added cursor's row is folded.
         */
        isFoldedAtCursorRow() : boolean;
    
        /**
         * Determine whether the given row in buffer coordinates is folded.
         * @param bufferRow? - A {Number}
         */
        isFoldedAtBufferRow(bufferRow? : number) : boolean;
    
        /**
         * Determine whether the given row in screen coordinates is folded.
         * @param screenRow? - A {Number}
         */
        isFoldedAtScreenRow(screenRow? : number) : boolean;
    
        /**
         * Rename to foldRowRange? 
         */
        createFold(startRow? : number, endRow? : number) : Fold;
    
        /**
         * {Delegates to: DisplayBuffer.destroyFoldWithId} 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        destroyFoldWithId(id? : any) : void;
    
        /**
         * Remove any {Fold}s found that intersect the given buffer range. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        destroyFoldsIntersectingBufferRange(bufferRange? : TextBuffer.Range) : TextBuffer.Range;
    
        /**
         * Remove any {Fold}s found that contain the given buffer range. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        destroyFoldsContainingBufferRange(bufferRange? : TextBuffer.Range) : TextBuffer.Range;
    
        /**
         * {Delegates to: DisplayBuffer.largestFoldContainingBufferRow} 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        largestFoldContainingBufferRow(bufferRow? : number) : number;
    
        /**
         * {Delegates to: DisplayBuffer.largestFoldStartingAtScreenRow} 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        largestFoldStartingAtScreenRow(screenRow? : number) : number;
    
        /**
         * {Delegates to: DisplayBuffer.outermostFoldsForBufferRowRange} 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        outermostFoldsInBufferRowRange(startRow? : number, endRow? : number) : TextBuffer.Range;
    
        /**
         * Scroll the editor to reveal the most recently added cursor if it is
         * off-screen.
         * @param options? - {Object}
         */
        scrollToCursorPosition(options? : Object) : TextBuffer.Point;
    
        /**
         * Scrolls the editor to the given buffer position.
         * @param bufferPosition? - An object that represents a buffer position. It can be either an {Object} (`{row, column}`), {Array} (`[row, column]`), or {Point}
         * @param options? - {Object}
         */
        scrollToBufferPosition(bufferPosition? : Object, options? : Object) : TextBuffer.Point;
    
        /**
         * Scrolls the editor to the given screen position.
         * @param screenPosition? - An object that represents a buffer position. It can be either  an {Object} (`{row, column}`), {Array} (`[row, column]`), or {Point}
         * @param options? - {Object}
         */
        scrollToScreenPosition(screenPosition? : Object, options? : Object) : TextBuffer.Point;
    
        /**
         * Scrolls the editor to the top 
         */
        scrollToTop() : any;
    
        /**
         * Scrolls the editor to the bottom 
         */
        scrollToBottom() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        scrollToScreenRange(screenRange? : TextBuffer.Range, options? : any) : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        horizontallyScrollable() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        verticallyScrollable() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getHorizontalScrollbarHeight() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setHorizontalScrollbarHeight(height? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getVerticalScrollbarWidth() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setVerticalScrollbarWidth(width? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pageUp() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pageDown() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        selectPageUp() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        selectPageDown() : any;
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
        Returns the number of rows per page
         */
        getRowsPerPage() : any;
    
        /**
         * Config
         * This field or method was marked private by atomdoc. Use with caution.
         */
        shouldAutoIndent() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        shouldAutoIndentOnPaste() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        shouldShowInvisibles() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateInvisibles() : void;
    
        /**
         * Event Handlers
         * This field or method was marked private by atomdoc. Use with caution.
         */
        handleTokenization() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        handleGrammarChange() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        handleMarkerCreated(marker? : Marker) : any;
    
        /**
         * Retrieves the greyed out placeholder of a mini editor.
         */
        getPlaceholderText() : string;
    
        /**
         * Set the greyed out placeholder of a mini editor. Placeholder text
         * will be displayed when the editor has no content.
         * @param placeholderText? - {String} text that is displayed when the editor has no content. 
         */
        setPlaceholderText(placeholderText? : string) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getFirstVisibleScreenRow(suppressDeprecation? : any) : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getLastVisibleScreenRow(suppressDeprecation? : any) : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pixelPositionForBufferPosition(bufferPosition? : TextBuffer.Point | { row: number; column: number } | [number, number], suppressDeprecation? : any) : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pixelPositionForScreenPosition(screenPosition? : TextBuffer.Point | { row: number; column: number } | [number, number], suppressDeprecation? : any) : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getSelectionMarkerAttributes() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getVerticalScrollMargin() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setVerticalScrollMargin(verticalScrollMargin? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getHorizontalScrollMargin() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setHorizontalScrollMargin(horizontalScrollMargin? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getLineHeightInPixels() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setLineHeightInPixels(lineHeightInPixels? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        batchCharacterMeasurement(fn? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getScopedCharWidth(scopeNames? : string, char? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setScopedCharWidth(scopeNames? : string, char? : any, width? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getScopedCharWidths(scopeNames? : string) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        clearScopedCharWidths() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getDefaultCharWidth() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setDefaultCharWidth(defaultCharWidth? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setHeight(height? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getHeight() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getClientHeight() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setWidth(width? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getWidth() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getScrollTop() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setScrollTop(scrollTop? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getScrollBottom() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setScrollBottom(scrollBottom? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getScrollLeft() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setScrollLeft(scrollLeft? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getScrollRight() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setScrollRight(scrollRight? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getScrollHeight() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getScrollWidth() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getVisibleRowRange() : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        intersectsVisibleRowRange(startRow? : number, endRow? : number) : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        selectionIntersectsVisibleRowRange(selection? : Range) : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        screenPositionForPixelPosition(pixelPosition? : TextBuffer.Point | { row: number; column: number } | [number, number]) : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pixelRectForScreenRange(screenRange? : TextBuffer.Range) : TextBuffer.Range;
    
        /**
         * Utility
         * This field or method was marked private by atomdoc. Use with caution.
         */
        inspect() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        logScreenLines(start? : any, end? : any) : any;
    
    }

    /**
     * Handles loading and activating available themes.
     */
    class ThemeManager {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        packageManager: PackageManager;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        resourcePath: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        configDirPath: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        safeMode: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(packageManager? : PackageManager, resourcePath? : any, configDirPath? : any, safeMode? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        styleElementAdded(styleElement? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        styleElementRemoved(styleElement? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        styleElementUpdated(sheet? : any) : any;
    
        /**
         * Invoke `callback` when style sheet changes associated with
         * updating the list of active themes have completed.
         * @param callback? - {Function} 
         */
        onDidChangeActiveThemes(callback? : Function) : EventKit.Disposable;
    
        /**
         * Accessing Available Themes
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getAvailableNames() : string;
    
        /**
         * Get an array of all the loaded theme names. 
         */
        getLoadedThemeNames() : string;
    
        /**
         * Get an array of all the loaded themes. 
         */
        getLoadedThemes() : any;
    
        /**
         * Get an array of all the active theme names. 
         */
        getActiveThemeNames() : string;
    
        /**
         * Get an array of all the active themes. 
         */
        getActiveThemes() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        activatePackages() : Q.Promise<Package>[];
    
        /**
         * Get the enabled theme names from the config.
         */
        getEnabledThemeNames() : string;
    
        /**
         * Resolve and apply the stylesheet specified by the path.
         * 
         * This supports both CSS and Less stylsheets.
         * This field or method was marked private by atomdoc. Use with caution.
         * @param stylesheetPath? - A {String} path to the stylesheet that can be an absolute path or a relative path that will be resolved against the load path.
        Returns a {Disposable} on which `.dispose()` can be called to remove the
required stylesheet.
         */
        requireStylesheet(stylesheetPath? : string) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        unwatchUserStylesheet() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        loadUserStylesheet() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        loadBaseStylesheets() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        reloadBaseStylesheets() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        stylesheetElementForId(id? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        resolveStylesheet(stylesheetPath? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        loadStylesheet(stylesheetPath? : any, importFallbackVariables? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        loadLessStylesheet(lessStylesheetPath? : any, importFallbackVariables? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        removeStylesheet(stylesheetPath? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        applyStylesheet(path? : any, text? : string) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        stringToId(string? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        activateThemes() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        deactivateThemes() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isInitialLoadComplete() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        addActiveThemeClasses() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        removeActiveThemeClasses() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        refreshLessCache() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getImportPaths() : any;
    
    }

    /**
     * ThemePackage
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class ThemePackage extends Package {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getType() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getStyleSheetPriority() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        enable() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        disable() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        load() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        activate() : void;
    
    }

    /**
     * Represents a single unit of text as selected by a grammar. 
     */
    class Token {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        bufferDelta: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isSoftWrapIndentation: boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        value: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        hasPairedCharacter: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        scopes: Scope[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isAtomic: boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isHardTab: boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        firstNonWhitespaceIndex: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        firstTrailingWhitespaceIndex: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        hasInvisibleCharacters: boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(value? : any, scopes? : Scope[], isAtomic? : boolean, bufferDelta? : any, isHardTab? : boolean, hasPairedCharacter? : any, isSoftWrapIndentation? : boolean);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isEqual(other? : any) : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isBracket() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        splitAt(splitIndex? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        whitespaceRegexForTabLength(tabLength? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        breakOutAtomicTokens(tabLength? : any, breakOutLeadingSoftTabs? : any, startColumn? : number) : Token[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        breakOutPairedCharacters() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildPairedCharacterToken(value? : any, index? : any) : Token;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildHardTabToken(tabLength? : any, column? : number) : Token;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildSoftTabToken(tabLength? : any) : Token;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildTabToken(tabLength? : any, isHardTab? : boolean, column? : number) : Token;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildSoftWrapIndentationToken(length? : any) : Token;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isOnlyWhitespace() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        matchesScopeSelector(selector? : FirstMate.ScopeSelector) : FirstMate.ScopeSelector;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getValueAsHtml(hasIndentGuide? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        escapeString(str? : any, startIndex? : any, endIndex? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        escapeStringReplace(match? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        hasLeadingWhitespace() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        hasTrailingWhitespace() : any;
    
    }

    /**
     * TokenizedBuffer
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class TokenizedBuffer extends Model {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        invisibles: boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        grammar: FirstMate.Grammar;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        currentGrammarScore: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buffer: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        tabLength: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        tokenizedLines: TokenizedLine[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        chunkSize: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        invalidRows: number[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        visible: boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(buffer? : any, tabLength? : any, invisibles? : boolean);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        destroyed() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        serializeParams() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        deserializeParams(params? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        observeGrammar(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidChangeGrammar(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidChange(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDidTokenize(callback? : any) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        grammarAddedOrUpdated(grammar? : FirstMate.Grammar) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setGrammar(grammar? : FirstMate.Grammar, score? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        reloadGrammar() : FirstMate.Grammar;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        hasTokenForSelector(selector? : ScopedPropertyStore.Selector) : ScopedPropertyStore.Selector;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        retokenizeLines() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setVisible(visible? : boolean) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getTabLength() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setTabLength(tabLength? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setInvisibles(invisibles? : boolean) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        tokenizeInBackground() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        tokenizeNextChunk() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        markTokenizationComplete() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        firstInvalidRow() : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        validateRow(row? : number) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        invalidateRow(row? : number) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateInvalidRows(start? : any, end? : any, delta? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        handleBufferChange(e? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        retokenizeWhitespaceRowsIfIndentLevelChanged(row? : number, increment? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateFoldableStatus(startRow? : number, endRow? : number) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isFoldableAtRow(row? : number) : boolean;
    
        /**
         * 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        isFoldableCodeAtRow(row? : number) : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isFoldableCommentAtRow(row? : number) : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildTokenizedLinesForRows(startRow? : number, endRow? : number, startingStack? : any) : number[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildPlaceholderTokenizedLinesForRows(startRow? : number, endRow? : number) : number[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildPlaceholderTokenizedLineForRow(row? : number) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildTokenizedLineForRow(row? : number, ruleStack? : any) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildTokenizedLineForRowWithText(row? : number, line? : any, ruleStack? : any) : string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        tokenizedLineForRow(bufferRow? : number) : TokenizedLine;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        stackForRow(bufferRow? : number) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        indentLevelForRow(bufferRow? : number) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        indentLevelForLine(line? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        scopeDescriptorForPosition(position? : TextBuffer.Point | { row: number; column: number } | [number, number]) : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        tokenForPosition(position? : TextBuffer.Point | { row: number; column: number } | [number, number]) : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        tokenStartPositionForPosition(position? : TextBuffer.Point | { row: number; column: number } | [number, number]) : TextBuffer.Point;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        bufferRangeForScopeAtPosition(selector? : ScopedPropertyStore.Selector, position? : TextBuffer.Point | { row: number; column: number } | [number, number]) : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        iterateTokensInBufferRange(bufferRange? : TextBuffer.Range, iterator? : any) : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        backwardsIterateTokensInBufferRange(bufferRange? : TextBuffer.Range, iterator? : any) : TextBuffer.Range;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        findOpeningBracket(startBufferPosition? : TextBuffer.Point | { row: number; column: number } | [number, number]) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        findClosingBracket(startBufferPosition? : TextBuffer.Point | { row: number; column: number } | [number, number]) : any;
    
        /**
         * Gets the row number of the last line.
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getLastRow() : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getLineCount() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        logLines(start? : any, end? : any) : any;
    
    }

    /**
     * TokenizedLine
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class TokenizedLine {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        lineEnding: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        ruleStack: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        startBufferColumn: number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        fold: Fold;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        tabLength: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        indentLevel: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        invisibles: boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        endOfLineInvisibles: boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        lineIsWhitespaceOnly: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        firstNonWhitespaceIndex: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        foldable: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(tokens? : Token[], lineEnding? : any, ruleStack? : any, startBufferColumn? : number, fold? : Fold, tabLength? : any, indentLevel? : any, invisibles? : boolean);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildText() : string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildBufferDelta() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        copy() : TokenizedLine;
    
        /**
         * This clips a given screen column to a valid column that's within the line
         * and not in the middle of any atomic tokens.
         * 
         * column - A {Number} representing the column to clip
         * options - A hash with the key clip. Valid values for this key:
         *           'closest' (default): clip to the closest edge of an atomic token.
         *           'forward': clip to the forward edge.
         *           'backward': clip to the backward edge.
         * This field or method was marked private by atomdoc. Use with caution.
         */
        clipScreenColumn(column? : number, options? : any) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        screenColumnForBufferColumn(bufferColumn? : number, options? : any) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        bufferColumnForScreenColumn(screenColumn? : number, options? : any) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getMaxScreenColumn() : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getMaxBufferColumn() : number;
    
        /**
         * Given a boundary column, finds the point where this line would wrap.
         * 
         * maxColumn - The {Number} where you want soft wrapping to occur
         * This field or method was marked private by atomdoc. Use with caution.
         */
        findWrapColumn(maxColumn? : number) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildSoftWrapIndentationTokens(token? : Token[], hangingIndent? : any) : Token[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        softWrapAt(column? : number, hangingIndent? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isSoftWrapped() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isColumnInsideSoftWrapIndentation(column? : number) : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getSoftWrapIndentationTokens() : Token[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildSoftWrapIndentationDelta() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        hasOnlySoftWrapIndentation() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        tokenAtBufferColumn(bufferColumn? : number) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        tokenIndexAtBufferColumn(bufferColumn? : number) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        tokenStartColumnForBufferColumn(bufferColumn? : number) : number;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        breakOutAtomicTokens(inputTokens? : Token[]) : Token[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        markLeadingAndTrailingWhitespaceTokens() : Token[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        substituteInvisibleCharacters() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        buildEndOfLineInvisibles() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isComment() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isOnlyWhitespace() : boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        tokenAtIndex(index? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getTokenCount() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        bufferColumnForToken(targetToken? : Token) : Token;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getScopeTree() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateScopeStack(scopeStack? : any, desiredScopeDescriptor? : ScopeDescriptor) : void;
    
    }

    /**
     * Scope
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class Scope {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        scope: Scope;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(scope? : Scope);
    
    }

    /**
     * Associates tooltips with HTML elements or selectors.
     */
    class TooltipManager {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        defaults: any /* default */;
    
        /**
         * Add a tooltip to the given element.
         * @param target? - An `HTMLElement`
         * @param options? - See http://getbootstrap.com/javascript/#tooltips for a full list of options. You can also supply the following additional options:
        Returns a {Disposable} on which `.dispose()` can be called to remove the
tooltip.
         */
        add(target? : any, options? : any) : EventKit.Disposable;
    
    }

    /**
     * `ViewRegistry` handles the association between model and view
     * types in Atom. We call this association a View Provider. As in, for a given
     * model, this class can provide a view via {::getView}, as long as the
     * model/view association was registered via {::addViewProvider}
     */
    class ViewRegistry {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        documentPollingInterval: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        documentUpdateRequested: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        performDocumentPollAfterUpdate: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pollIntervalHandle: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor();
    
        /**
         * Add a provider that will be used to construct views in the
         * workspace's view layer based on model objects in its model layer.
        Returns a {Disposable} on which `.dispose()` can be called to remove the
added provider.
         */
        addViewProvider(modelConstructor? : any, createView? : (model: any) => HTMLElement) : EventKit.Disposable;
    
        /**
         * Get the view associated with an object in the workspace.
         * 
         * If you're just *using* the workspace, you shouldn't need to access the view
         * layer, but view layer access may be necessary if you want to perform DOM
         * manipulation that isn't supported via the model API.
         * @param object? - The object for which you want to retrieve a view. This can be a pane item, a pane, or the workspace itself.
         */
        getView(object? : any) : SpacePen.View;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        createView(object? : any) : (model: any) => HTMLElement;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        findProvider(object? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        updateDocument(fn? : any) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        readDocument(fn? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pollDocument(fn? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        pollAfterNextUpdate() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        clearDocumentRequests() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        requestDocumentUpdate() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        performDocumentUpdate() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        startPollingDocument() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        stopPollingDocument() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        performDocumentPoll() : any;
    
    }

    /**
     * Handles low-level events related to the window. 
     */
    class WindowEventHandler {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor();
    
        /**
         * Wire commands that should be handled by the native menu
         * for elements with the `.native-key-bindings` class. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        handleNativeKeybindings() : AtomKeymap.KeyBinding[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onKeydown(event? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDrop(event? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onDragOver(event? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        openLink(target? : any, currentTarget? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        eachTabIndexedElement(callback? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        focusNext() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        focusPrevious() : any;
    
    }

    /**
     * The top-level view for the entire window. An instance of this class is
     * available via the `atom.workspaceView` global.
     */
    class WorkspaceView extends SpacePen.View {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        element: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(element? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setModel(model? : Model) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        beforeRemove() : any;
    
        /**
         * Get the underlying model object.
         */
        getModel() : Model;
    
        /**
         * Register a function to be called for every current and future
         * editor view in the workspace (only includes {TextEditorView}s that are pane
         * items).
         * @param callback? - A {Function} with an {TextEditorView} as its only argument.
         */
        eachEditorView(callback? : Function) : SpacePen.View;
    
        /**
         * Register a function to be called for every current and future
         * pane view in the workspace.
         * @param callback? - A {Function} with a {PaneView} as its only argument.
         */
        eachPaneView(callback? : Function) : PaneView;
    
        /**
         * Get all existing pane views.
         * 
         * Prefer {Workspace::getPanes} if you don't need access to the view objects.
         * Also consider using {::eachPaneView} if you want to register a callback for
         * all current and *future* pane views.
         */
        getPaneViews() : PaneView[];
    
        /**
         * Get the active pane view.
         * 
         * Prefer {Workspace::getActivePane} if you don't actually need access to the
         * view.
         */
        getActivePaneView() : PaneView;
    
        /**
         * Get the view associated with the active pane item.
         */
        getActiveView() : SpacePen.View;
    
        /**
         * Adding elements to the workspace
         * This field or method was marked private by atomdoc. Use with caution.
         */
        prependToTop(element? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        appendToTop(element? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        prependToBottom(element? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        appendToBottom(element? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        prependToLeft(element? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        appendToLeft(element? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        prependToRight(element? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        appendToRight(element? : any) : any;
    
        /**
         * Focus the previous pane by id. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        focusPreviousPaneView() : PaneView;
    
        /**
         * Focus the next pane by id. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        focusNextPaneView() : PaneView;
    
        /**
         * Focus the pane directly above the active pane. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        focusPaneViewAbove() : any;
    
        /**
         * Focus the pane directly below the active pane. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        focusPaneViewBelow() : any;
    
        /**
         * Focus the pane directly to the left of the active pane. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        focusPaneViewOnLeft() : any;
    
        /**
         * Focus the pane directly to the right of the active pane. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        focusPaneViewOnRight() : any;
    
        /**
         * Prompts to save all unsaved items 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        confirmClose() : any;
    
        /**
         * Get all editor views.
         * 
         * You should prefer {Workspace::getEditors} unless you absolutely need access
         * to the view objects. Also consider using {::eachEditorView}, which will call
         * a callback for all current and *future* editor views.
         * This field or method was marked private by atomdoc. Use with caution.
         */
        getEditorViews() : SpacePen.View[];
    
        /**
         * Call {Workspace::getActivePaneItem} instead. 
         */
        getActivePaneItem() : any;
    
    }

    /**
     * Represents the state of the user interface for the entire window.
     * An instance of this class is available via the `atom.workspace` global.
     */
    class Workspace extends Model {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(params? : any);
    
        /**
         * Called by the Serializable mixin during deserialization 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        deserializeParams(params? : any) : any;
    
        /**
         * Called by the Serializable mixin during serialization. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        serializeParams() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getPackageNamesWithActiveGrammars() : FirstMate.Grammar[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        editorAdded(editor? : TextEditor) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        installShellCommands() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        subscribeToActiveItem() : any;
    
        /**
         * Updates the application's title and proxy icon based on whichever file is
         * open. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        updateWindowTitle() : void;
    
        /**
         * On OS X, fades the application window's proxy icon when the current file
         * has been modified. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        updateDocumentEdited() : void;
    
        /**
         * Invoke the given callback with all current and future text
         * editors in the workspace.
         * @param callback - {Function} to be called with current and future text editors.
         */
        observeTextEditors(callback : (editor: Atom.TextEditor) => void) : EventKit.Disposable;
    
        /**
         * Invoke the given callback with all current and future panes items
         * in the workspace.
         * @param callback? - {Function} to be called with current and future pane items.
         */
        observePaneItems(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when the active pane item changes.
         * @param callback? - {Function} to be called when the active pane item changes.
         */
        onDidChangeActivePaneItem(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback with the current active pane item and
         * with all future active pane items in the workspace.
         * @param callback? - {Function} to be called when the active pane item changes.
         */
        observeActivePaneItem(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback whenever an item is opened. Unlike
         * {::onDidAddPaneItem}, observers will be notified for items that are already
         * present in the workspace when they are reopened.
         * @param callback? - {Function} to be called whenever an item is opened.
         */
        onDidOpen(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when a pane is added to the workspace.
         * @param callback? - {Function} to be called panes are added.
         */
        onDidAddPane(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when a pane is destroyed in the
         * workspace.
         * @param callback? - {Function} to be called panes are destroyed.
         */
        onDidDestroyPane(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback with all current and future panes in the
         * workspace.
         * @param callback? - {Function} to be called with current and future panes.
         */
        observePanes(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when the active pane changes.
         * @param callback? - {Function} to be called when the active pane changes.
         */
        onDidChangeActivePane(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback with the current active pane and when
         * the active pane changes.
         * @param callback? - {Function} to be called with the current and future active# panes.
         */
        observeActivePane(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when a pane item is added to the
         * workspace.
         * @param callback? - {Function} to be called when pane items are added.
         */
        onDidAddPaneItem(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when a pane item is about to be
         * destroyed, before the user is prompted to save it.
         * @param callback? - {Function} to be called before pane items are destroyed.
         */
        onWillDestroyPaneItem(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when a pane item is destroyed.
         * @param callback? - {Function} to be called when pane items are destroyed.
         */
        onDidDestroyPaneItem(callback? : Function) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when a text editor is added to the
         * workspace.
         * @param callback? - {Function} to be called panes are added.
         */
        onDidAddTextEditor(callback? : Function) : EventKit.Disposable;
    
        /**
         * Opens the given URI in Atom asynchronously.
         * If the URI is already open, the existing item for that URI will be
         * activated. If no URI is given, or no registered opener can open
         * the URI, a new empty {TextEditor} will be created.
         * @param uri? - A {String} containing a URI.
         * @param options? - {Object}
         */
        open(uri? : string, options? : Object) : Q.Promise<TextEditor>;
    
        /**
         * Open Atom's license in the active pane. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        openLicense() : any;
    
        /**
         * Synchronously open the given URI in the active pane. **Only use this method
         * in specs. Calling this in production code will block the UI thread and
         * everyone will be mad at you.**
         * This field or method was marked private by atomdoc. Use with caution.
         * @param uri? - A {String} containing a URI.
         * @param options? - An optional options {Object}
         */
        openSync(uri? : string, options? : Object) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        openURIInPane(uri? : any, pane? : Pane, options? : any) : Pane;
    
        /**
         * Asynchronously reopens the last-closed item's URI if it hasn't already been
         * reopened.
        Returns a promise that is resolved when the item is opened
         */
        reopenItem() : any;
    
        /**
         * Register an opener for a uri.
         * 
         * An {TextEditor} will be used if no openers return a value.
         * @param opener? - A {Function} to be called when a path is being opened.
        Returns a {Disposable} on which `.dispose()` can be called to remove the
opener.
         */
        addOpener(opener? : Function) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getOpeners() : any;
    
        /**
         * Get all pane items in the workspace.
        Returns an {Array} of items.
         */
        getPaneItems() : any[];
    
        /**
         * Get the active {Pane}'s active item.
        Returns an pane item {Object}.
         */
        getActivePaneItem() : Object;
    
        /**
         * Get all text editors in the workspace.
         */
        getTextEditors() : TextEditor[];
    
        /**
         * Get the active item if it is an {TextEditor}.
         */
        getActiveTextEditor() : TextEditor;
    
        /**
         * Save all pane items. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        saveAll() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        confirmClose(options? : any) : any;
    
        /**
         * Save the active pane item.
         * 
         * If the active pane item currently has a URI according to the item's
         * `.getURI` method, calls `.save` on the item. Otherwise
         * {::saveActivePaneItemAs} # will be called instead. This method does nothing
         * if the active item does not implement a `.save` method. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        saveActivePaneItem() : void;
    
        /**
         * Prompt the user for a path and save the active pane item to it.
         * 
         * Opens a native dialog where the user selects a path on disk, then calls
         * `.saveAs` on the item with the selected path. This method does nothing if
         * the active item does not implement a `.saveAs` method. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        saveActivePaneItemAs() : void;
    
        /**
         * Destroy (close) the active pane item.
         * 
         * Removes the active pane item and calls the `.destroy` method on it if one is
         * defined. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        destroyActivePaneItem() : void;
    
        /**
         * Get all panes in the workspace.
         */
        getPanes() : Pane[];
    
        /**
         * Get the active {Pane}.
         */
        getActivePane() : Pane;
    
        /**
         * Make the next pane active. 
         */
        activateNextPane() : void;
    
        /**
         * Make the previous pane active. 
         */
        activatePreviousPane() : void;
    
        /**
         * Get the first {Pane} with an item for the given URI.
         * @param uri? - {String} uri
        Returns a {Pane} or `` if no pane exists for the given URI.
         */
        paneForURI(uri? : string) : Pane;
    
        /**
         * Get the {Pane} containing the given item.
         * @param item? - Item the returned pane contains.
        Returns a {Pane} or `` if no pane exists for the given item.
         */
        paneForItem(item? : any) : Pane;
    
        /**
         * Destroy (close) the active pane. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        destroyActivePane() : void;
    
        /**
         * Destroy the active pane item or the active pane if it is empty. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        destroyActivePaneItemOrEmptyPane() : void;
    
        /**
         * Increase the editor font size by 1px. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        increaseFontSize() : void;
    
        /**
         * Decrease the editor font size by 1px. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        decreaseFontSize() : void;
    
        /**
         * Restore to a default editor font size. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        resetFontSize() : void;
    
        /**
         * Removes the item's uri from the list of potential items to reopen. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        itemOpened(item? : any) : any;
    
        /**
         * Adds the destroyed item's uri to the list of items to reopen. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        didDestroyPaneItem(item? : any) : any;
    
        /**
         * Called by Model superclass when destroyed 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        destroyed() : void;
    
        /**
         * Get an {Array} of all the panel items at the bottom of the editor window. 
         */
        getBottomPanels() : Panel[];
    
        /**
         * Adds a panel item to the bottom of the editor window.
         * @param options? - {Object}
         */
        addBottomPanel(options? : { item: Node | JQuery | Object; visible?: boolean; priority?: number; }) : Panel;
    
        /**
         * Get an {Array} of all the panel items to the left of the editor window. 
         */
        getLeftPanels() : Panel[];
    
        /**
         * Adds a panel item to the left of the editor window.
         * @param options? - {Object}
         */
        addLeftPanel(options? : { item: Node | JQuery | Object; visible?: boolean; priority?: number; }) : Panel;
    
        /**
         * Get an {Array} of all the panel items to the right of the editor window. 
         */
        getRightPanels() : Panel[];
    
        /**
         * Adds a panel item to the right of the editor window.
         * @param options? - {Object}
         */
        addRightPanel(options? : { item: Node | JQuery | Object; visible?: boolean; priority?: number; }) : Panel;
    
        /**
         * Get an {Array} of all the panel items at the top of the editor window. 
         */
        getTopPanels() : Panel[];
    
        /**
         * Adds a panel item to the top of the editor window above the tabs.
         * @param options? - {Object}
         */
        addTopPanel(options? : { item: Node | JQuery | Object; visible?: boolean; priority?: number; }) : Panel;
    
        /**
         * Get an {Array} of all the modal panel items 
         */
        getModalPanels() : Panel[];
    
        /**
         * Adds a panel item as a modal dialog.
         * @param options? - {Object}
         */
        addModalPanel(options? : { item: Node | JQuery | Object; visible?: boolean; priority?: number; }) : Panel;
    
        panelForItem(item? : any) : Panel | any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        getPanels(location? : any) : Panel[];
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        addPanel(location? : any, options? : any) : Panel;
    
        /**
         * Performs a search across all the files in the workspace.
         * @param regex? - {RegExp} to search with.
         * @param options? - {Object} (default: {})
         * @param iterator? - {Function} callback on each file found
        Returns a `Promise`.
         */
        scan(regex? : RegExp, options? : Object, iterator? : Function) : any;
    
        /**
         * Performs a replace across all the specified files in the project.
         * @param regex? - A {RegExp} to search with.
         * @param replacementText? - Text to replace all matches of regex with
         * @param filePaths? - List of file path strings to run the replace on.
         * @param iterator? - A {Function} callback on each file with replacements:
        Returns a `Promise`.
         */
        replace(regex? : RegExp, replacementText? : string, filePaths? : any, iterator? : Function) : any;
    
    }

}
declare module "atom" {
    class BufferedNodeProcess extends Atom.BufferedNodeProcess {}
    class BufferedProcess extends Atom.BufferedProcess {}
    class GitRepository extends Atom.GitRepository {}
    class Range extends Atom.Range {}
    class Notification extends Atom.Notification {}
    var Point : typeof TextBuffer.Point;
    var File : typeof Pathwatcher.File;
    var Directory : typeof Pathwatcher.Directory;
    var Emitter : typeof EventKit.Emitter;
    var Disposable : typeof EventKit.Disposable;
    var CompositeDisposable : typeof EventKit.CompositeDisposable;
}

//${content}
declare module "fs-plus" {
    import fs = require("fs");
    export = fs;
}

declare var atom: Atom.Atom;
